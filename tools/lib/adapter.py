"""Generic X→Graph adapter toolkit for quicue.ca.

Shared utilities for converting external specs (CycloneDX, GitLab CI,
SPDX, STIX, Helm, etc.) into #InfraGraph input. Each adapter implements
a parse function that returns (components, deps); this module handles
everything else: ID sanitization, Kahn's depth, CUE/JSON rendering, CLI.

Usage in an adapter:

    from lib.adapter import BaseAdapter, to_safe_id, compute_depths

    class MyAdapter(BaseAdapter):
        name = "myspec"
        description = "Convert MySpec to #InfraGraph"

        def parse(self, path, args):
            # ... parse spec ...
            return components, deps

    if __name__ == "__main__":
        MyAdapter().run()

The components dict maps safe_id -> {name, @type: {Type: True}, ...}.
The deps dict maps safe_id -> {dep_safe_id: True, ...}.
"""

import argparse
import collections
import json
import re
import sys
from pathlib import Path


# ---------------------------------------------------------------------------
# ID sanitization
# ---------------------------------------------------------------------------

def to_safe_id(s: str) -> str:
    """Convert an external identifier to a #SafeID-compliant key.

    #SafeID = ^[a-zA-Z][a-zA-Z0-9_.-]*$
    """
    s = re.sub(r"[^a-zA-Z0-9_.-]", "-", s)
    s = re.sub(r"-+", "-", s)
    s = s.strip("-.")
    if not s:
        return "unnamed"
    if not s[0].isalpha():
        s = "x-" + s
    return s


# ---------------------------------------------------------------------------
# Topological sort (Kahn's algorithm)
# ---------------------------------------------------------------------------

def compute_depths(components: dict, deps: dict) -> dict:
    """Compute topological depth for each node via Kahn's algorithm.

    Root nodes (no dependencies) get depth 0.
    A node's depth = max(depth of its dependencies) + 1.
    Handles cycles by assigning max_depth + 1.
    """
    in_degree = {cid: 0 for cid in components}
    forward = collections.defaultdict(list)

    for cid, dep_map in deps.items():
        count = 0
        for dep_id in dep_map:
            if dep_id in components:
                forward[dep_id].append(cid)
                count += 1
        in_degree[cid] = count

    depth = {}
    queue = collections.deque()
    for cid in components:
        if in_degree.get(cid, 0) == 0:
            queue.append(cid)
            depth[cid] = 0

    while queue:
        node = queue.popleft()
        for dependent in forward[node]:
            new_depth = depth[node] + 1
            if dependent not in depth or new_depth > depth[dependent]:
                depth[dependent] = new_depth
            in_degree[dependent] -= 1
            if in_degree[dependent] == 0:
                queue.append(dependent)

    # Cycle fallback
    if len(depth) < len(components):
        max_d = max(depth.values()) if depth else 0
        for cid in components:
            if cid not in depth:
                depth[cid] = max_d + 1

    return depth


# ---------------------------------------------------------------------------
# CUE rendering
# ---------------------------------------------------------------------------

def escape_cue_string(s: str) -> str:
    """Escape a string for CUE output."""
    return s.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n")


def render_cue(components: dict, deps: dict, depths: dict,
               package: str, source: str, header_lines: list[str] | None = None,
               metadata_fields: list[str] | None = None) -> str:
    """Render components and deps as a CUE file with #InfraGraph wiring.

    Args:
        components: {safe_id: {name, @type, ...}}
        deps: {safe_id: {dep_id: True, ...}}
        depths: {safe_id: int}
        package: CUE package name
        source: Source filename for the header comment
        header_lines: Additional header comment lines
        metadata_fields: Field names to include from components (beyond name/@type/depends_on)
    """
    if metadata_fields is None:
        metadata_fields = []

    lines = []
    lines.append(f"// {package} — generated from {source}")
    if header_lines:
        for hl in header_lines:
            lines.append(f"// {hl}")
    lines.append(f"//")
    lines.append(f"// Components: {len(components)}")
    lines.append(f"// Generated by: quicue.ca adapter toolkit")
    lines.append(f"")
    lines.append(f"package {package}")
    lines.append(f"")
    lines.append(f"import (")
    lines.append(f'\t"quicue.ca/patterns@v0"')
    lines.append(f")")
    lines.append(f"")

    # Resources
    lines.append(f"_resources: {{")
    for cid in sorted(components, key=lambda k: depths.get(k, 0)):
        comp = components[cid]
        lines.append(f'\t"{cid}": {{')
        lines.append(f'\t\tname: "{cid}"')

        types = sorted(comp["@type"].keys())
        type_str = ", ".join(f"{t}: true" for t in types)
        lines.append(f'\t\t"@type": {{{type_str}}}')

        if cid in deps and deps[cid]:
            dep_ids = sorted(deps[cid].keys())
            dep_str = ", ".join(f'"{d}": true' for d in dep_ids)
            lines.append(f"\t\tdepends_on: {{{dep_str}}}")

        for field in metadata_fields:
            val = comp.get(field)
            if val is None:
                continue
            if isinstance(val, bool):
                lines.append(f"\t\t{field}: {'true' if val else 'false'}")
            elif isinstance(val, (int, float)):
                lines.append(f"\t\t{field}: {val}")
            else:
                lines.append(f'\t\t{field}: "{escape_cue_string(str(val))}"')

        lines.append(f"\t}}")

    lines.append(f"}}")
    lines.append(f"")

    # Precomputed depths
    lines.append(f"_precomputed: {{")
    lines.append(f"\tdepth: {{")
    for cid in sorted(depths, key=lambda k: (depths[k], k)):
        lines.append(f'\t\t"{cid}": {depths[cid]}')
    lines.append(f"\t}}")
    lines.append(f"}}")
    lines.append(f"")

    # Graph wiring
    lines.append(f"infra: patterns.#InfraGraph & {{")
    lines.append(f"\tInput:       _resources")
    lines.append(f"\tPrecomputed: _precomputed")
    lines.append(f"}}")

    return "\n".join(lines) + "\n"


def render_json(components: dict, deps: dict, depths: dict) -> str:
    """Render as JSON for piping to other tools."""
    output = {"resources": {}, "precomputed": {"depth": depths}}
    for cid, comp in components.items():
        entry = {"name": cid, "@type": comp["@type"]}
        if cid in deps:
            entry["depends_on"] = deps[cid]
        for k, v in comp.items():
            if k not in ("name", "@type"):
                entry[k] = v
        output["resources"][cid] = entry
    return json.dumps(output, indent=2) + "\n"


# ---------------------------------------------------------------------------
# Base adapter class
# ---------------------------------------------------------------------------

class BaseAdapter:
    """Base class for X→Graph adapters.

    Subclasses implement:
        name: str           — adapter short name
        description: str    — CLI help text
        parse(path, args)   — returns (components, deps)

    Optionally override:
        metadata_fields     — list of field names to include with --metadata
        add_arguments(parser) — add adapter-specific CLI arguments
        default_package(path) — derive package name from input path
    """

    name: str = "adapter"
    description: str = "Convert external spec to #InfraGraph"
    metadata_fields: list[str] = []

    def parse(self, path: str, args: argparse.Namespace) -> tuple[dict, dict]:
        """Parse the input file. Returns (components, deps)."""
        raise NotImplementedError

    def add_arguments(self, parser: argparse.ArgumentParser) -> None:
        """Add adapter-specific CLI arguments."""
        pass

    def default_package(self, path: str) -> str:
        """Derive a CUE package name from the input path."""
        pkg = re.sub(r"[^a-zA-Z0-9]", "", Path(path).stem.lower())
        if not pkg or not pkg[0].isalpha():
            pkg = self.name
        return pkg

    def run(self) -> None:
        """CLI entry point."""
        parser = argparse.ArgumentParser(
            description=self.description,
            formatter_class=argparse.RawDescriptionHelpFormatter,
        )
        parser.add_argument("input", help="Path to input file")
        parser.add_argument("-o", "--output", help="Output file (default: stdout)")
        parser.add_argument("-p", "--package", help="CUE package name")
        parser.add_argument("--metadata", action="store_true",
                            help="Include additional metadata fields")
        parser.add_argument("--json", action="store_true",
                            help="Output JSON instead of CUE")
        parser.add_argument("--stats", action="store_true",
                            help="Print stats to stderr")
        self.add_arguments(parser)

        args = parser.parse_args()

        components, deps = self.parse(args.input, args)
        depths = compute_depths(components, deps)

        package = args.package or self.default_package(args.input)

        if args.stats:
            n_edges = sum(len(d) for d in deps.values())
            max_depth = max(depths.values()) if depths else 0
            roots = sum(1 for d in depths.values() if d == 0)
            print(f"Components: {len(components)}", file=sys.stderr)
            print(f"Edges: {n_edges}", file=sys.stderr)
            print(f"Max depth: {max_depth}", file=sys.stderr)
            print(f"Roots: {roots}", file=sys.stderr)

        meta = self.metadata_fields if args.metadata else []

        if args.json:
            output = render_json(components, deps, depths)
        else:
            output = render_cue(
                components, deps, depths, package,
                Path(args.input).name, metadata_fields=meta,
            )

        if args.output:
            Path(args.output).parent.mkdir(parents=True, exist_ok=True)
            Path(args.output).write_text(output)
            print(f"Wrote {args.output} ({len(components)} components)", file=sys.stderr)
        else:
            sys.stdout.write(output)
