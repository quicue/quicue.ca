name: Validate

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  semantic:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate Turtle syntax
        run: |
          sudo apt-get install -y -qq raptor2-utils
          for f in semantic/*.ttl; do
            echo "=== $(basename $f) ==="
            rapper -c -i turtle "$f"
          done

      - name: Validate SPARQL query syntax
        run: |
          pip install -q rdflib
          python3 -c "
          import glob, sys
          from rdflib.plugins.sparql import prepareQuery

          failed = 0
          for f in sorted(glob.glob('semantic/queries/*.rq')):
              try:
                  with open(f) as fh:
                      prepareQuery(fh.read())
                  print(f'OK: {f}')
              except Exception as e:
                  print(f'FAIL: {f}: {e}')
                  failed += 1

          if failed:
              print(f'{failed} query(ies) failed syntax check')
              sys.exit(1)
          print(f'All {len(glob.glob(\"semantic/queries/*.rq\"))} SPARQL queries valid')
          "

  cue-vet:
    runs-on: ubuntu-latest
    env:
      CUE_REGISTRY: none
    steps:
      - uses: actions/checkout@v4

      - name: Install CUE
        uses: cue-lang/setup-cue@v1.0.1
        with:
          version: v0.15.4

      - name: Validate core vocabulary
        run: cue vet ./vocab/ ./patterns/ ./charter/ -c

      - name: Validate all examples
        run: |
          for d in examples/*/; do
            echo "=== $(basename $d) ==="
            cue vet "./$d" -c
          done

      - name: Validate all provider templates
        run: |
          for d in template/*/; do
            echo "=== $(basename $d) ==="
            cue vet "./$d/..." -c
          done

      - name: No hardcoded absolute paths in markdown
        run: |
          FOUND=0
          for f in $(find . -name '*.md' -not -path './.git/*' -not -path '*/node_modules/*'); do
            if grep -nE '(/home/|/Users/)' "$f"; then
              echo "  ^ in $f"
              FOUND=$((FOUND + 1))
            fi
          done
          if [ "$FOUND" -gt 0 ]; then
            echo "ERROR: $FOUND file(s) contain hardcoded absolute paths"
            exit 1
          fi
          echo "No hardcoded absolute paths found"

  binding:
    runs-on: ubuntu-latest
    needs: cue-vet
    env:
      CUE_REGISTRY: none
    steps:
      - uses: actions/checkout@v4

      - name: Install CUE
        uses: cue-lang/setup-cue@v1.0.1
        with:
          version: v0.15.4

      - name: Generate OpenAPI spec from datacenter example
        run: |
          cue export ./examples/datacenter/ -e openapi_spec --out json > /tmp/openapi.json
          echo "Spec size: $(wc -c < /tmp/openapi.json)B"

      - name: Generate bound commands
        run: |
          cue export ./examples/datacenter/ -e 'output.commands' --out json > /tmp/bound_commands.json
          echo "Bound commands size: $(wc -c < /tmp/bound_commands.json)B"

      - name: Validate all 29 providers have bound commands
        run: |
          python3 -c "
          import json, sys
          with open('/tmp/bound_commands.json') as f:
              bound = json.load(f)

          # Collect all provider prefixes from bound commands
          providers = set()
          total_commands = 0
          for resource, commands in bound.items():
              for action_key in commands:
                  provider = action_key.split('/')[0]
                  providers.add(provider)
                  total_commands += 1

          print(f'Resources: {len(bound)}')
          print(f'Providers with bindings: {len(providers)}')
          print(f'Total bound commands: {total_commands}')
          print(f'Providers: {sorted(providers)}')

          # At least 28 providers should bind (technitium may not have a resource)
          if len(providers) < 28:
              print(f'FAIL: Only {len(providers)} providers have bound commands, expected >= 28')
              sys.exit(1)

          # No unresolved template placeholders (e.g. {node}, {ctid})
          # Exclude JSON bodies like {\"key\":...} and shell constructs
          import re
          placeholder_re = re.compile(r'\{[a-z_]+\}')
          for resource, commands in bound.items():
              for action_key, command in commands.items():
                  matches = placeholder_re.findall(command)
                  if matches:
                      print(f'FAIL: Unresolved placeholder in {resource}/{action_key}: {matches} in {command}')
                      sys.exit(1)

          print('All bindings resolved, no placeholders')
          "

      - name: Validate no private IPs leaked into spec
        run: |
          # Block ALL RFC 1918 private ranges, not just 172.20
          for f in /tmp/openapi.json /tmp/bound_commands.json; do
            if grep -qP '172\.(1[6-9]|2[0-9]|3[01])\.\d+\.\d+' "$f"; then
              echo "FAIL: RFC 1918 172.16-31.x.x IPs found in $f"
              exit 1
            fi
            if grep -qP '192\.168\.\d+\.\d+' "$f"; then
              echo "FAIL: RFC 1918 192.168.x.x IPs found in $f"
              exit 1
            fi
          done
          echo "No private IPs in generated files"

  operator:
    runs-on: ubuntu-latest
    needs: cue-vet
    env:
      CUE_REGISTRY: none
    steps:
      - uses: actions/checkout@v4

      - name: Install CUE
        uses: cue-lang/setup-cue@v1.0.1
        with:
          version: v0.15.4

      - name: Build operator dashboard
        run: bash operator/build.sh

      - name: IP safety check on built output
        run: bash operator/check-ips.sh operator/public

  server:
    runs-on: ubuntu-latest
    needs: binding
    env:
      CUE_REGISTRY: none
    steps:
      - uses: actions/checkout@v4

      - name: Install CUE
        uses: cue-lang/setup-cue@v1.0.1
        with:
          version: v0.15.4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install server dependencies
        run: pip install -r server/requirements.txt

      - name: Install test dependencies
        run: pip install pytest httpx pytest-asyncio

      - name: Run unit tests
        run: pytest server/tests/ -v

      - name: Generate full spec for integration test
        run: cue export ./examples/datacenter/ -e openapi_spec --out json > /tmp/quicue-openapi.json

      - name: Start server and smoke test all routes
        run: |
          # Start the real server against the full generated spec
          QUICUE_SPEC_PATH=/tmp/quicue-openapi.json \
          QUICUE_API_TOKEN=ci-test-token \
          QUICUE_TRUSTED_SUBNET=127.0.0.0/8 \
          QUICUE_DEPLOY_LOG_PATH=/tmp/deploy.jsonl \
          QUICUE_DEPLOY_LOCK_PATH=/tmp/deploy.lock.json \
            uvicorn app.main:app --host 127.0.0.1 --port 8000 --app-dir server &
          SERVER_PID=$!

          # Wait for server to be ready
          for i in $(seq 1 30); do
            if curl -sf http://127.0.0.1:8000/api/v1/healthz > /dev/null 2>&1; then
              break
            fi
            sleep 1
          done

          # Health check
          HEALTH=$(curl -sf http://127.0.0.1:8000/api/v1/healthz)
          ROUTE_COUNT=$(echo "$HEALTH" | python3 -c "import json,sys; print(json.load(sys.stdin)['route_count'])")
          echo "Server loaded $ROUTE_COUNT routes"

          if [ "$ROUTE_COUNT" -lt 600 ]; then
            echo "FAIL: Expected >= 600 routes, got $ROUTE_COUNT"
            kill $SERVER_PID
            exit 1
          fi

          # Hit every route in mock mode using the generated OpenAPI spec
          python3 -c "
          import json, urllib.request, sys

          with open('/tmp/quicue-openapi.json') as f:
              spec = json.load(f)

          paths = [p for p in spec.get('paths', {}).keys() if p.startswith('/resources/')]
          print(f'Testing {len(paths)} resource routes...')

          total = 0
          failed = 0
          for path in paths:
              url = f'http://127.0.0.1:8000/api/v1{path}'
              try:
                  req = urllib.request.Request(url, method='POST', data=b'{}',
                      headers={'Content-Type': 'application/json'})
                  resp = urllib.request.urlopen(req)
                  total += 1
              except urllib.error.HTTPError as e:
                  # 200=mock ok, 403=auth required, 423=locked â€” all acceptable
                  if e.code in (403, 423):
                      total += 1
                  else:
                      print(f'FAIL {e.code}: {path}')
                      failed += 1
                      total += 1

          print(f'Tested {total}/{len(paths)} routes, {failed} failures')
          if failed > 0:
              sys.exit(1)
          " || { kill $SERVER_PID; exit 1; }

          kill $SERVER_PID
          echo "All routes passed"

  deploy-demo:
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    needs: operator
    env:
      CUE_REGISTRY: none
    steps:
      - uses: actions/checkout@v4

      - name: Install CUE
        uses: cue-lang/setup-cue@v1.0.1
        with:
          version: v0.15.4

      - name: Build operator dashboard
        run: bash operator/build.sh

      - name: Deploy to Cloudflare Pages
        run: |
          npx wrangler pages project create quicue-demo --production-branch=main || echo "Project may already exist"
          npx wrangler pages deploy operator/public --project-name=quicue-demo --branch=main
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        continue-on-error: true

  deploy-api:
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    needs: server
    env:
      CUE_REGISTRY: none
    steps:
      - uses: actions/checkout@v4

      - name: Install CUE
        uses: cue-lang/setup-cue@v1.0.1
        with:
          version: v0.15.4

      - name: Build static API
        run: bash server/build-static-api.sh /tmp/static-api

      - name: Deploy to Cloudflare Pages
        run: |
          npx wrangler pages project create quicue-api --production-branch=main || echo "Project may already exist"
          npx wrangler pages deploy /tmp/static-api --project-name=quicue-api --branch=main
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        continue-on-error: true
