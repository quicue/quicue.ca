{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"quicue.ca","text":"<p>Model it in CUE. Validate by unification. Export to whatever the world expects.</p>"},{"location":"#what-this-is","title":"What this is","text":"<p>You declare resources \u2014 nodes in a graph \u2014 with types and dependencies. CUE computes the rest: dependency layers, transitive closure, blast radius, deployment plans, linked data exports. The gap between your constraints and your data IS the remaining work. When <code>cue vet</code> passes, you're done.</p> <pre><code>dns: #Resource &amp; {\n    \"@type\":     {LXCContainer: true, DNSServer: true}\n    depends_on:  {router: true}\n    host:        \"node-1\"\n    container_id: 101\n}\n</code></pre> <p>No runtime. No state file. No plugins. CUE validates everything simultaneously, and the output is plain JSON.</p>"},{"location":"#overview","title":"Overview","text":"Metric Count Modules 12 Decisions (ADRs) 14 KB Patterns 16 Insights 14 Semantic Types 57 Downstream Consumers 3 Deployed Sites 7"},{"location":"#modules","title":"Modules","text":"Module Layer Description vocab <code>definition</code> Core schemas: #Resource, #Action, #TypeRegistry, #ActionDef patterns <code>definition</code> Algorithms: graph, bind, deploy, health, SPOF, viz, TOON, OpenAPI, validation templates <code>template</code> 29 platform-specific providers, each a self-contained CUE module orche <code>orchestration</code> Orchestration schemas: execution steps, federation, drift detection, Docker site bootstrap boot <code>orchestration</code> Bootstrap schemas: #BootstrapResource, #BootstrapPlan, credential collectors wiki <code>projection</code> #WikiProjection \u2014 MkDocs site generation from resource graphs cab <code>reporting</code> Change Advisory Board reports: impact, blast radius, runbooks ou <code>interaction</code> Role-scoped views: #InteractionCtx narrows #ExecutionPlan by role, type, name, layer. Hydra W3C JSON-LD export. ci <code>ci</code> Reusable GitLab CI templates for CUE validation, export, topology, impact server <code>operations</code> FastAPI execution gateway for running infrastructure commands charter <code>constraint</code> Constraint-first project planning: declare scope, evaluate gaps, track gates. SHACL gap report projection. examples <code>value</code> 17 working examples from minimal 3-layer to full 30-resource datacenter"},{"location":"#not-just-infrastructure","title":"Not just infrastructure","text":"<p>The graph patterns are domain-agnostic. <code>#BlastRadius</code>, <code>#ImpactQuery</code>, <code>#SinglePointsOfFailure</code>, and <code>#DeploymentPlan</code> don't know what domain they're in. \"What breaks if X goes down?\" works whether X is a DNS server, a construction phase, or a research gene.</p> Domain What the graph models Live IT infrastructure 30 servers, containers, and services across 7 dependency layers datacenter example Construction management Deep retrofit work packages for 270-unit community housing program CMHC Retrofit Energy efficiency 17-service processing platform for Ontario Greener Homes Greener Homes Real estate operations Transaction pipelines, referral networks, compliance workflows maison-613"},{"location":"#what-it-computes","title":"What it computes","text":"Pattern What it answers <code>#InfraGraph</code> Dependency layers, transitive closure, topology <code>#BindCluster</code> Which providers match which resources, resolved commands <code>#ImpactQuery</code> \"What breaks if X goes down?\" <code>#BlastRadius</code> Change impact with rollback order <code>#SinglePointsOfFailure</code> Resources with no redundancy <code>#HealthStatus</code> Simulated failure propagation <code>#DeploymentPlan</code> Ordered layers with gates <code>#ExecutionPlan</code> All of the above, unified <code>#Charter</code> What \"done\" looks like \u2014 scope, gates, completion <code>#GapAnalysis</code> What's missing, what's next, which gates are satisfied <p>See the Pattern Catalog for the full list and Charter for project planning.</p>"},{"location":"#downstream-consumers","title":"Downstream Consumers","text":"Project Domain Patterns Used grdn Production infrastructure graph \u2014 multi-node cluster with ZFS storage, networking, and container orchestration 14 cmhc-retrofit Construction program management (NHCF deep retrofit, Greener Homes processing platform) 15 maison-613 Real estate operations \u2014 7 graphs (transaction, referral, compliance, listing, operations, onboarding, client) 14"},{"location":"#ecosystem-sites","title":"Ecosystem Sites","text":"Site Description docs MkDocs Material documentation site demo Operator dashboard \u2014 D3 graph, planner, resource browser api Static API showcase \u2014 727 pre-computed JSON endpoints cat DCAT 3 data catalogue kg Knowledge graph framework spec cmhc-retrofit Construction program management showcase maison613 Real estate operations showcase"},{"location":"#contract-via-unification","title":"Contract-via-unification","text":"<p>Verification IS unification. You write CUE constraints that must merge with the computed graph. If they can't unify, <code>cue vet</code> rejects everything:</p> <pre><code>// This must merge with the computed graph output.\n// If docker isn't the root, or validation fails, cue vet rejects.\nvalidate: valid: true\ninfra: roots: {\"docker\": true}\ndeployment: layers: [{layer: 0, resources: [\"docker\"]}, ...]\n</code></pre> <p>No assertion framework. No test runner. The contract IS CUE values. Unification IS the enforcement.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>git clone https://github.com/quicue/quicue.ca.git\ncd quicue.ca\n\n# Validate schemas\ncue vet ./vocab/ ./patterns/\n\n# Run the datacenter example\ncue eval ./examples/datacenter/ -e output.summary\n\n# What breaks if the router goes down?\ncue eval ./examples/datacenter/ -e output.impact.\"router-core\"\n\n# Export as JSON-LD\ncue export ./examples/datacenter/ -e jsonld --out json\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Apache 2.0</p>"},{"location":"architecture/","title":"Architecture","text":"<p>quicue.ca models any domain as typed dependency graphs in CUE. This document explains how the layers compose, what each module does, and how data flows from resource definitions to executable plans.</p>"},{"location":"architecture/#four-layer-model","title":"Four-layer model","text":"<pre><code>Definition (vocab/)          What things ARE and what you can DO to them\n    \u2193\nPattern (patterns/)          How to analyze, bind, plan, and export\n    \u2193\nTemplate (template/*/)       Platform-specific action implementations\n    \u2193\nValue (examples/, your code) Concrete infrastructure instances\n</code></pre> <p>Each layer imports only from the layer below it. CUE's type system enforces that values satisfy all constraints from every layer simultaneously \u2014 there is no runtime, no fallback, and no partial evaluation.</p>"},{"location":"architecture/#module-dependency-graph","title":"Module Dependency Graph","text":"<pre><code>graph TD\n    vocab[\"vocab&lt;br/&gt;&lt;i&gt;definition&lt;/i&gt;\"]\n    patterns[\"patterns&lt;br/&gt;&lt;i&gt;definition&lt;/i&gt;\"]\n    templates[\"templates&lt;br/&gt;&lt;i&gt;template&lt;/i&gt;\"]\n    orche[\"orche&lt;br/&gt;&lt;i&gt;orchestration&lt;/i&gt;\"]\n    boot[\"boot&lt;br/&gt;&lt;i&gt;orchestration&lt;/i&gt;\"]\n    wiki[\"wiki&lt;br/&gt;&lt;i&gt;projection&lt;/i&gt;\"]\n    cab[\"cab&lt;br/&gt;&lt;i&gt;reporting&lt;/i&gt;\"]\n    ou[\"ou&lt;br/&gt;&lt;i&gt;interaction&lt;/i&gt;\"]\n    ci[\"ci&lt;br/&gt;&lt;i&gt;ci&lt;/i&gt;\"]\n    server[\"server&lt;br/&gt;&lt;i&gt;operations&lt;/i&gt;\"]\n    charter[\"charter&lt;br/&gt;&lt;i&gt;constraint&lt;/i&gt;\"]\n    examples[\"examples&lt;br/&gt;&lt;i&gt;value&lt;/i&gt;\"]\n    orche --&gt; patterns\n    ou --&gt; patterns\n    charter --&gt; patterns</code></pre>"},{"location":"architecture/#layers","title":"Layers","text":""},{"location":"architecture/#definition","title":"definition","text":"<ul> <li>vocab \u2014 Core schemas: #Resource, #Action, #TypeRegistry, #ActionDef</li> <li>patterns \u2014 Algorithms: graph, bind, deploy, health, SPOF, viz, TOON, OpenAPI, validation</li> </ul>"},{"location":"architecture/#template","title":"template","text":"<ul> <li>templates \u2014 29 platform-specific providers, each a self-contained CUE module</li> </ul>"},{"location":"architecture/#orchestration","title":"orchestration","text":"<ul> <li>orche \u2014 Orchestration schemas: execution steps, federation, drift detection, Docker site bootstrap</li> <li>boot \u2014 Bootstrap schemas: #BootstrapResource, #BootstrapPlan, credential collectors</li> </ul>"},{"location":"architecture/#constraint","title":"constraint","text":"<ul> <li>charter \u2014 Constraint-first project planning: declare scope, evaluate gaps, track gates. SHACL gap report projection.</li> </ul>"},{"location":"architecture/#projection","title":"projection","text":"<ul> <li>wiki \u2014 #WikiProjection \u2014 MkDocs site generation from resource graphs</li> </ul>"},{"location":"architecture/#reporting","title":"reporting","text":"<ul> <li>cab \u2014 Change Advisory Board reports: impact, blast radius, runbooks</li> </ul>"},{"location":"architecture/#interaction","title":"interaction","text":"<ul> <li>ou \u2014 Role-scoped views: #InteractionCtx narrows #ExecutionPlan by role, type, name, layer. Hydra W3C JSON-LD export.</li> </ul>"},{"location":"architecture/#ci","title":"ci","text":"<ul> <li>ci \u2014 Reusable GitLab CI templates for CUE validation, export, topology, impact</li> </ul>"},{"location":"architecture/#operations","title":"operations","text":"<ul> <li>server \u2014 FastAPI execution gateway for running infrastructure commands</li> </ul>"},{"location":"architecture/#value","title":"value","text":"<ul> <li>examples \u2014 17 working examples from minimal 3-layer to full 30-resource datacenter</li> </ul>"},{"location":"architecture/#definition-layer-vocab","title":"Definition layer: <code>vocab/</code>","text":""},{"location":"architecture/#resource","title":"<code>#Resource</code>","text":"<p>The foundation. Every infrastructure component is a <code>#Resource</code>:</p> <pre><code>dns: vocab.#Resource &amp; {\n    name:         \"dns\"\n    \"@type\":      {LXCContainer: true, DNSServer: true}\n    depends_on:   {router: true}\n    host:         \"pve-node1\"\n    container_id: 101\n    ip:           \"198.51.100.211\"\n}\n</code></pre> <p>Key design decisions:</p> <ul> <li>Struct-as-set for <code>@type</code> and <code>depends_on</code>. <code>{LXCContainer: true}</code> gives O(1) membership checks. Patterns test <code>resource[\"@type\"][SomeType] != _|_</code> instead of iterating a list.</li> <li>Generic field names. <code>host</code> (not <code>node</code>), <code>container_id</code> (not <code>lxcid</code>). Providers map generic names to platform-specific commands.</li> <li>Open schema (<code>...</code>). Resources can carry domain-specific fields without modifying vocab.</li> <li>ASCII-safe identifiers. All resource names, <code>@type</code> keys, <code>depends_on</code> keys are constrained to ASCII via <code>#SafeID</code> and <code>#SafeLabel</code> regex patterns. This prevents zero-width unicode injection and homoglyph attacks at compile time.</li> </ul>"},{"location":"architecture/#action-and-actiondef","title":"<code>#Action</code> and <code>#ActionDef</code>","text":"<p>Actions are executable operations. Two schemas serve different purposes:</p> <ul> <li><code>#Action</code> \u2014 a resolved action with a concrete <code>command</code> string. This is what the binding layer produces.</li> <li><code>#ActionDef</code> \u2014 an action definition with typed parameters and a command template. Providers declare these; the binding layer resolves them against resources.</li> </ul> <pre><code>// ActionDef (provider declares this)\nping: vocab.#ActionDef &amp; {\n    name:             \"Ping\"\n    description:      \"Test connectivity\"\n    category:         \"info\"\n    params:           {ip: {from_field: \"ip\"}}\n    command_template: \"ping -c 3 {ip}\"\n    idempotent:       true\n}\n</code></pre> <p>The <code>from_field</code> key is what makes compile-time binding work. If a resource lacks the field a parameter needs, the action is silently omitted (not an error \u2014 the provider simply doesn't apply to that resource).</p>"},{"location":"architecture/#pattern-layer-patterns","title":"Pattern layer: <code>patterns/</code>","text":""},{"location":"architecture/#bindcluster-command-resolution","title":"<code>#BindCluster</code> \u2014 command resolution","text":"<p>Matches providers to resources by <code>@type</code> overlap and resolves command templates:</p> <pre><code>cluster: patterns.#BindCluster &amp; {\n    resources: _resources\n    providers: {\n        proxmox: patterns.#ProviderDecl &amp; {\n            types:    {LXCContainer: true, VirtualMachine: true}\n            registry: proxmox_patterns.#ProxmoxRegistry\n        }\n    }\n}\n// cluster.bound.dns.actions.proxmox.container_status.command = \"pct status 101\"\n</code></pre> <p>The binding algorithm:</p> <ol> <li>For each resource, iterate all providers</li> <li>If <code>provider.types \u2229 resource[\"@type\"] \u2260 \u2205</code>, the provider matches</li> <li>For each action in the provider's registry, check if all required parameters resolve from resource fields</li> <li>Resolve the command template with <code>#ResolveTemplate</code> (compile-time substitution, up to 8 parameters)</li> <li>Produce a concrete <code>vocab.#Action</code> with the resolved command</li> </ol>"},{"location":"architecture/#executionplan-the-unifier","title":"<code>#ExecutionPlan</code> \u2014 the unifier","text":"<p>Composes binding, graph analysis, and deployment planning over the same resource set:</p> <pre><code>execution: patterns.#ExecutionPlan &amp; {\n    resources: _resources\n    providers: _providers\n}\n// execution.cluster.bound     \u2014 resources with resolved commands\n// execution.graph.topology    \u2014 dependency layers\n// execution.plan.layers       \u2014 ordered deployment with gates\n</code></pre> <p>CUE enforces that all three agree. If a resource's dependencies are inconsistent with its binding, evaluation fails \u2014 not at deploy time, at <code>cue vet</code> time.</p>"},{"location":"architecture/#export-projections","title":"Export projections","text":"<p>The execution plan can be projected into multiple output formats:</p> Projection Format Target <code>notebook</code> <code>.ipynb</code> JSON Jupyter runbook with per-layer cells <code>rundeck</code> YAML Rundeck job definitions <code>http</code> <code>.http</code> RFC 9110 REST Client files <code>wiki</code> Markdown MkDocs site (index + per-resource pages) <code>script</code> Bash Self-contained deployment script with parallelism <code>ops</code> JSON Task list for <code>cue cmd</code> consumption ## Extension modules"},{"location":"architecture/#ou-role-scoped-views","title":"<code>ou/</code> \u2014 Role-scoped views","text":"<p>Role-scoped views that filter resources and actions by role: <code>ops</code> (full access), <code>dev</code> (read-only monitoring), <code>readonly</code> (status queries only). Exports W3C Hydra JSON-LD for semantic API navigation.</p>"},{"location":"architecture/#boot-bootstrap-sequencing","title":"<code>boot/</code> \u2014 Bootstrap sequencing","text":"<p>Credential collection and bootstrap ordering for initial infrastructure setup. Handles the chicken-and-egg problem (e.g., you need DNS to reach the vault, but you need the vault to configure DNS).</p>"},{"location":"architecture/#cab-change-advisory-board","title":"<code>cab/</code> \u2014 Change Advisory Board","text":"<p>Generates CAB reports from impact analysis: what's changing, what's affected, what's the rollback plan, who needs to approve.</p>"},{"location":"architecture/#wiki-documentation-generation","title":"<code>wiki/</code> \u2014 Documentation generation","text":"<p>Produces MkDocs-compatible markdown from the resource graph: index page, per-layer views, per-resource detail pages.</p>"},{"location":"architecture/#server-fastapi-gateway","title":"<code>server/</code> \u2014 FastAPI gateway","text":"<p>HTTP API for executing resolved commands. Reads the CUE-generated OpenAPI spec and exposes actions as REST endpoints. Live at api.quicue.ca (public, mock mode).</p>"},{"location":"architecture/#kg-knowledge-graph","title":"<code>kg/</code> \u2014 Knowledge graph","text":"<p>The <code>.kb/</code> directory at the repo root is a multi-graph knowledge base with typed subdirectories (decisions/, patterns/, insights/, rejected/), each validated against its kg type.</p>"},{"location":"architecture/#data-flow-summary","title":"Data flow summary","text":"<pre><code>1. Define resources (CUE values with @type and depends_on)\n                    \u2193\n2. Declare providers (type matching + action registries)\n                    \u2193\n3. #ExecutionPlan unifies:\n   \u251c\u2500\u2500 #BindCluster  \u2192 resolved commands per resource per provider\n   \u251c\u2500\u2500 #InfraGraph   \u2192 depth, ancestors, topology, dependents\n   \u2514\u2500\u2500 #DeploymentPlan \u2192 ordered layers with gates\n                    \u2193\n4. CUE validates everything simultaneously:\n   - Missing fields \u2192 compile error\n   - Dangling dependencies \u2192 validation error\n   - Type mismatches \u2192 unification error\n                    \u2193\n5. Export to any format:\n   - cue export -e output --out json          \u2192 full execution data\n   - cue export -e execution.notebook         \u2192 Jupyter runbook\n   - cue export -e execution.script --out text \u2192 deployment script\n   - cue export -e jsonld --out json          \u2192 JSON-LD graph\n</code></pre>"},{"location":"architecture/#key-invariants","title":"Key Invariants","text":"<ol> <li>No runtime template resolution. Every <code>{param}</code> placeholder is resolved at <code>cue vet</code> time. If a command has an unresolved placeholder, it won't compile.</li> <li>The graph is the source of truth. Deployment plans, rollback sequences, blast radius, documentation, and visualizations are all computed from the same unified constraint set.</li> <li>Struct-as-set everywhere. <code>@type</code>, <code>depends_on</code>, <code>provides</code>, and <code>tags</code> all use <code>{key: true}</code> structs for O(1) membership testing.</li> <li>Hidden fields for export control. CUE exports all public fields. Intermediate computation uses hidden fields (<code>_depth</code>, <code>_ancestors</code>, <code>_graph</code>) to prevent JSON bloat.</li> <li>Topology-sensitive transitive closure. CUE's fixpoint computation for <code>_ancestors</code> is bottlenecked by fan-in (edge density), not node count.</li> </ol>"},{"location":"charter/","title":"Charter","text":"<p><code>quicue.ca/charter</code> \u2014 constraint-first project planning via CUE unification.</p> <p>Declare what \"done\" looks like. Build the graph incrementally. <code>cue vet</code> tells you what's missing. When it passes, the charter is satisfied.</p> <p>The gap between constraints and data IS the remaining work.</p>"},{"location":"charter/#schemas","title":"Schemas","text":"<ul> <li><code>#Charter</code></li> <li><code>#Gate</code></li> <li><code>#GapAnalysis</code></li> <li><code>#Milestone</code></li> <li><code>#InfraCharter</code></li> </ul>"},{"location":"charter/#how-it-works","title":"How It Works","text":"<p>A charter is a set of CUE constraints that the project graph must eventually satisfy. You declare scope (what must exist), gates (checkpoints along the way), and let CUE compute the delta.</p> <pre><code>import \"quicue.ca/charter\"\n\n_charter: charter.#Charter &amp; {\n    name: \"NHCF Deep Retrofit\"\n    scope: {\n        total_resources: 18\n        root:            \"nhcf-agreement\"\n        required_resources: {\"rideau-design\": true, \"gladstone-design\": true}\n        required_types: {Assessment: true, Design: true, Retrofit: true}\n        min_depth: 3\n    }\n    gates: {\n        \"assessment-complete\": {\n            phase: 1\n            requires: {\"site-audit\": true, \"energy-model\": true}\n        }\n        \"design-complete\": {\n            phase: 3\n            requires: {\"rideau-design\": true, \"gladstone-design\": true}\n            depends_on: {\"assessment-complete\": true}\n        }\n    }\n}\n</code></pre>"},{"location":"charter/#gap-analysis","title":"Gap Analysis","text":"<p><code>#GapAnalysis</code> takes a charter and a graph, and computes what's missing:</p> Field Type Description <code>complete</code> <code>bool</code> <code>true</code> when all constraints are satisfied <code>missing_resources</code> <code>{[string]: true}</code> Named resources not yet in the graph <code>missing_types</code> <code>{[string]: true}</code> Required types not represented <code>depth_satisfied</code> <code>bool</code> Graph reaches <code>min_depth</code> <code>gate_status</code> <code>{[name]: {satisfied, missing, ready}}</code> Per-gate evaluation <code>unsatisfied_gates</code> <code>{[name]: {missing}}</code> Gates not yet met <code>next_gate</code> <code>string</code> Lowest-phase unsatisfied gate <p>When <code>gaps.complete == true</code>, the charter is satisfied. When it's <code>false</code>, the missing fields tell you exactly what to build next.</p>"},{"location":"charter/#scope-constraints","title":"Scope constraints","text":"<p>The <code>scope</code> block supports five constraint types, all optional:</p> Constraint Type Meaning <code>total_resources</code> <code>int &amp; &gt;0</code> Minimum resource count <code>root</code> <code>string \\| {[string]: true}</code> Named root(s) that must exist as graph roots <code>required_resources</code> <code>{[string]: true}</code> Resources that must exist by name <code>required_types</code> <code>{[string]: true}</code> Types that must be represented <code>min_depth</code> <code>int &amp; &gt;=0</code> Minimum graph depth"},{"location":"charter/#live-integrations","title":"Live integrations","text":"<p>Charter is used across five downstream projects, each a different domain shape:</p> Project Graph Nodes Gates Domain cmhc-retrofit NHCF Project delivery 18 5 Construction PM cmhc-retrofit Greener Homes Service topology 17 5 IT platform maison-613 Transaction Deal phases 16 6 Real estate maison-613 Compliance Obligation graph 12 4 Regulatory grdn Infrastructure 50 2 Homelab"},{"location":"charter/#validation","title":"Validation","text":"<pre><code>cue vet ./charter/\n</code></pre>"},{"location":"federation/","title":"Federation","text":"<p>quicue.ca projects federate knowledge through CUE's type system and W3C linked data standards. No external triplestore, no SPARQL endpoint, no contract test framework. CUE unification already is one.</p>"},{"location":"federation/#the-kb-pattern","title":"The .kb/ pattern","text":"<p>Each project that uses quicue.ca can maintain a <code>.kb/</code> directory \u2014 a multi-graph knowledge base tracking decisions, patterns, insights, and rejected approaches:</p> <pre><code>your-project/\n  .kb/\n    cue.mod/module.cue       # Root module\n    manifest.cue              # #KnowledgeBase \u2014 declares graph topology\n    decisions/\n      cue.mod/module.cue      # Independent CUE module\n      decisions.cue           # core.#Decision entries\n    patterns/\n      patterns.cue            # core.#Pattern entries\n    insights/\n      insights.cue            # core.#Insight entries\n    rejected/\n      rejected.cue            # core.#Rejected entries\n</code></pre> <p>Each subdirectory validates independently with <code>cue vet .</code> \u2014 directory structure IS the ontology.</p>"},{"location":"federation/#downstream-consumers","title":"Downstream Consumers","text":"Project Module Patterns Status Has KB grdn <code>grdn.quicue.ca</code> 14 active no cmhc-retrofit <code>quicue.ca/cmhc-retrofit@v0</code> 15 active yes maison-613 <code>rfam.cc/maison-613@v0</code> 14 active yes"},{"location":"federation/#dependency-tracking","title":"Dependency tracking","text":"<p>A downstream project's <code>deps.cue</code> records every definition it imports from quicue.ca:</p> <pre><code>_pattern_deps: {\n    \"#InfraGraph\": {\n        source:  \"quicue.ca/patterns@v0\"\n        used_in: [\"graph.cue\"]\n        purpose: \"Dependency graph computation\"\n    }\n    \"#BlastRadius\": {\n        source:  \"quicue.ca/patterns@v0\"\n        used_in: [\"projections.cue\"]\n        purpose: \"Transitive impact scope\"\n    }\n}\n</code></pre> <p>This is documentation. The enforcement comes from CUE itself \u2014 if <code>#InfraGraph</code> changes a field name, every file that imports it fails to unify.</p>"},{"location":"federation/#how-federation-works","title":"How Federation Works","text":"<p>Multiple teams maintain independent <code>.kb/</code> directories in their own repos. \"Federating\" them is just importing and letting CUE unify. If two teams assert contradictory values for the same field, <code>cue vet</code> produces a unification error. Conflicts are caught at build time, not discovered in a meeting six months later.</p> <p>CUE struct unification is:</p> <ul> <li>Commutative \u2014 order of import doesn't matter</li> <li>Idempotent \u2014 importing the same fact twice is harmless</li> <li>Conflict-detecting \u2014 contradictory values fail loudly</li> </ul> <p>No merge strategy. No conflict resolution policy. The lattice handles it.</p>"},{"location":"federation/#the-rejected-type","title":"The #Rejected type","text":"<p><code>#Rejected</code> requires an <code>alternative</code> field \u2014 you can't record \"we tried X and it failed\" without saying where to go instead. In a federated setup, a failed experiment in one team's repo becomes a navigational signpost for another team.</p> <pre><code>rejected_001: core.#Rejected &amp; {\n    id:          \"rejected-001\"\n    title:       \"VizExport pattern for graph rendering\"\n    date:        \"2025-12-10\"\n    description: \"Attempted #VizExport wrapper \u2014 CUE exports ALL public fields, causing 4x JSON bloat\"\n    reason:      \"Public field leak: Graph field exported entire input struct (75KB vs 17KB)\"\n    alternative: \"Use hidden _viz wrapper + explicit viz: {data: _viz.data, resources: ...}\"\n}\n</code></pre>"},{"location":"federation/#cross-references","title":"Cross-References","text":"<p>SKOS vocabulary alignment enables cross-namespace navigation:</p> <ul> <li><code>skos:exactMatch</code> \u2014 \"See also\" links between equivalent concepts across registries</li> <li><code>skos:closeMatch</code> \u2014 \"Related\" links between similar concepts in different domains</li> <li><code>skos:broader</code> / <code>skos:narrower</code> \u2014 hierarchical breadcrumbs within a concept scheme</li> </ul> <p>The <code>make check-downstream</code> target runs <code>cue vet</code> on all registered consumers. Renaming a field in <code>#InfraGraph</code> produces a unification error in any consumer that references it, caught at build time rather than discovered in production.</p>"},{"location":"finds-brief/","title":"quicue.ca \u2014 what fell out of one CUE value","text":"<p>A dependency graph. 30 resources. Two fields: <code>@type</code> and <code>depends_on</code>. Both are <code>{Key: true}</code> structs. One <code>cue export</code> produces 72+ projections.</p> <p>Four things that surprised me.</p>"},{"location":"finds-brief/#1-type-overlap-is-dispatch","title":"1. Type overlap is dispatch","text":"<p>Providers declare what types they serve. Resources declare what they are. Binding is one bottom test:</p> <pre><code>let _matched = [\n    for tname, _ in provider.types\n    if resource[\"@type\"][tname] != _|_ {tname},\n]\n</code></pre> <p>A resource with <code>{LXCContainer: true, DNSServer: true}</code> matches both Proxmox and PowerDNS simultaneously. Swap <code>LXCContainer</code> for <code>DockerContainer</code> and Docker binds instead. 29 providers, zero special cases.</p>"},{"location":"finds-brief/#2-transitive-closure-is-six-lines","title":"2. Transitive closure is six lines","text":"<pre><code>_ancestors: {\n    [_]: true\n    if _hasDeps {\n        for d, _ in _deps {\n            (d): true\n            resources[d]._ancestors\n        }\n    }\n}\n</code></pre> <p>I wrote \"include your parents' ancestors.\" CUE resolved the fixpoint. Graph algorithms as value declarations.</p>"},{"location":"finds-brief/#3-every-query-is-already-a-field","title":"3. Every query is already a field","text":"<pre><code>affected: {\n    for rname, r in Graph.resources\n    if r._ancestors[Target] != _|_ {(rname): true}\n}\n</code></pre> <p>Impact analysis, blast radius, SPOF detection, criticality ranking \u2014 each is one comprehension over <code>_ancestors</code>. <code>cue export</code> produces every answer. The API is 727 static JSON files on a CDN.</p>"},{"location":"finds-brief/#4-constraints-are-values-not-assertions","title":"4. Constraints are values, not assertions","text":"<pre><code>validate: valid: true\ninfra: roots: {\"docker\": true}\nimpact_docker: affected: {\n    for name, _ in _resources if name != \"docker\" {\n        \"\\(name)\": true\n    }\n}\n</code></pre> <p>Same package as the computation. If the graph disagrees, unification is bottom. <code>cue vet</code> fails. No test framework \u2014 the language is one.</p> <p>Same patterns serve IT infrastructure (30 resources, 654 commands), construction PM (18 CMHC work packages), energy efficiency (17-service platform), and real estate workflows. The domain is in the data, not the framework.</p> <p>The graph also produces JSON-LD, Hydra, DCAT, N-Triples, SHACL, and ODRL \u2014 each is one more CUE definition over the same resources.</p> <p>github.com/quicue/quicue.ca | demo | api | docs</p>"},{"location":"finds/","title":"Finds","text":"<p>Things I found building quicue.ca \u2014 a CUE framework where everything is a projection of one typed dependency graph.</p>"},{"location":"finds/#its-one-value","title":"It's one value","text":"<p>Every resource declares what it is (<code>@type</code>) and what it needs (<code>depends_on</code>). Both are struct-as-set:</p> <pre><code>\"dns-internal\": {\n    \"@type\": {LXCContainer: true, DNSServer: true, CriticalInfra: true}\n    depends_on: {\"pve-node1\": true}\n    host:         \"pve-node1\"\n    container_id: 100\n}\n</code></pre> <p><code>{Key: true}</code> as a set works because CUE merges structs. No duplicates, O(1) membership, composition is unification.</p> <p>From 30 resources and two fields, <code>cue export</code> produces 72+ projections: deployment plans, rollback sequences, blast radius, 654 resolved CLI commands, Jupyter notebooks, Rundeck jobs, a wiki, JSON-LD, Hydra, DCAT, N-Triples, SHACL shapes, ODRL policies, D3 data, DOT, Mermaid. One evaluation, no pipeline.</p>"},{"location":"finds/#type-overlap-as-dispatch","title":"Type overlap as dispatch","text":"<p>Standard tools \u2014 Docker, Proxmox, Kubernetes, Ansible, Vault, ArgoCD \u2014 all expose typed operations on resources. Good CLI specs, uniform shape. The binding logic is one comprehension:</p> <pre><code>// patterns/bind.cue\nlet _matched = [\n    for tname, _ in provider.types\n    if resource[\"@type\"][tname] != _|_ {tname},\n]\nif len(_matched) &gt; 0 {\n    (pname): (#BindActions &amp; {\n        \"registry\": provider.registry\n        \"resource\": resource\n    }).actions\n}\n</code></pre> <p>A provider declares <code>types: {LXCContainer: true}</code>. A resource declares <code>\"@type\": {LXCContainer: true, DNSServer: true}</code>. Binding is <code>resource[\"@type\"][tname] != _|_</code>.</p> <p>That DNS server matches Proxmox (serves LXCContainer) and PowerDNS (serves DNSServer) simultaneously. No registration, no interface declaration.</p> <p>Provider swapping is a type-set change. Replace <code>LXCContainer</code> with <code>DockerContainer</code> and Docker binds instead of Proxmox \u2014 the set intersection changed, so the dispatch changed. This is why 29 providers work without 29 special cases.</p>"},{"location":"finds/#transitive-closure-from-unification","title":"Transitive closure from unification","text":"<p>\"What are ALL the ancestors of this resource?\" In a procedural language, that's BFS. In CUE:</p> <pre><code>// patterns/graph.cue\n_ancestors: {\n    [_]: true\n    if _hasDeps {\n        for d, _ in _deps {\n            (d): true\n            resources[d]._ancestors\n        }\n    }\n}\n</code></pre> <p>Six lines. Declares a struct shape, adds direct parents, unifies with each parent's ancestors. CUE resolves the fixpoint \u2014 the struct expands until merging produces no new keys, then stops.</p> <p>I wrote \"include your parents' ancestors\" and CUE figured out the termination. The code credits the \"rogpeppe pattern.\" Whether this was designed for or emergent, it lets you write graph algorithms as value declarations.</p>"},{"location":"finds/#every-query-is-already-computed","title":"Every query is already computed","text":"<p>Once <code>_ancestors</code> exists, impact analysis is one comprehension:</p> <pre><code>// patterns/graph.cue\naffected: {\n    for rname, r in Graph.resources\n    if r._ancestors[Target] != _|_ {(rname): true}\n}\n</code></pre> <p>\"Which resources have Target in their ancestor set?\" That's the entire implementation of \"what breaks if this goes down.\"</p> <p>Blast radius wraps it and adds rollback ordering. Criticality ranking counts downstream dependents. SPOF detection finds nodes whose failure cascades widest. Each is a comprehension over the same <code>_ancestors</code>.</p> <p>There is no query planner, no index, no runtime. <code>cue export</code> produces every answer at eval time.</p> <p>Consequence: if every answer is known at build time, the API is a file server. The project serves 727 pre-computed JSON files from a CDN. No server, no database. CUE comprehensions enumerate all possible queries, so the static API is just those answers as files.</p>"},{"location":"finds/#constraints-are-values","title":"Constraints are values","text":"<p>Instead of assertions that check output, I write CUE values that must unify with the output:</p> <pre><code>// examples/devbox/verify.cue\npackage devbox\n\nvalidate: valid: true\ninfra: roots: {\"docker\": true}\ndeployment: layers: [{layer: 0, resources: [\"docker\"]}, ...]\nimpact_docker: affected: {\n    for name, _ in _resources if name != \"docker\" {\n        \"\\(name)\": true\n    }\n}\n</code></pre> <p>Same package as the computation. If the graph produces <code>validate: valid: false</code>, unification with <code>true</code> is bottom. <code>cue vet</code> fails. No assertion framework \u2014 the language is one.</p> <p>The charter module generalizes this: declare what \"done\" looks like (required resources, gates, type coverage), and <code>#GapAnalysis</code> computes the delta. The gap is the remaining work. The backlog is a CUE value.</p>"},{"location":"finds/#the-w3c-stack-is-more-projections","title":"The W3C stack is more projections","text":"<p>The same graph produces a full semantic web pipeline. Each W3C format is one more CUE definition over the same resources:</p> Format What it produces W3C spec JSON-LD <code>@graph</code> with typed IRIs, <code>dependsOn</code> links, <code>@context</code> JSON-LD 1.1 Hydra Role-scoped API docs: <code>supportedOperation</code> from bound actions Hydra Core DCAT 3 <code>dcat:Catalog</code> with <code>dcat:Dataset</code> per resource DCAT 3 N-Triples One triple per line \u2014 <code>rdf:type</code>, <code>dependsOn</code> edges RDF 1.1 SHACL Node shapes from the type registry \u2014 validates RDF data SHACL ODRL Machine-readable access policies per resource ODRL 2.2 ActivityStreams Change feeds \u2014 deploy\u2192<code>as:Create</code>, shutdown\u2192<code>as:Delete</code> AS 2.0 <p>No converters, no export pipelines. Each takes <code>#InfraGraph</code>, produces the target vocabulary's JSON-LD shape. They compose because they share input. They're correct because CUE validates structure at eval time.</p> <p>Inside CUE, comprehensions are the query layer. Outside CUE \u2014 when the data joins external systems \u2014 SPARQL and triplestores add value. The N-Triples and JSON-LD exports are the bridge.</p>"},{"location":"finds/#package-scoping-as-a-knowledge-base","title":"Package scoping as a knowledge base","text":"<p>CUE packages are directory-scoped. We use this for a multi-graph knowledge base:</p> <pre><code>.kb/\n\u251c\u2500\u2500 manifest.cue       # Topology via #KnowledgeBase\n\u251c\u2500\u2500 decisions/         # PROV-O\n\u251c\u2500\u2500 insights/          # Web Annotation\n\u251c\u2500\u2500 patterns/          # SKOS\n\u2514\u2500\u2500 rejected/          # PROV-O\n</code></pre> <p>Each subdirectory is an independent CUE package. A schema violation in <code>decisions/</code> can't poison <code>patterns/</code>. The directory structure is the ontology. The root manifest declares which graphs exist and what W3C vocabulary each maps to.</p> <p>We didn't build a knowledge base framework. We organized files into directories and let CUE's module system handle the isolation.</p>"},{"location":"finds/#it-works-across-domains","title":"It works across domains","text":"<p>Same <code>#InfraGraph</code>, same <code>#ImpactQuery</code>, same <code>#Charter</code> \u2014 four domains:</p> Domain Graph Shape IT infrastructure 30 resources, 29 providers, 654 commands Service topology Construction PM 18 CMHC deep retrofit work packages Project delivery Energy efficiency 17-service Greener Homes platform Platform topology Real estate Transaction pipeline, compliance tracker Workflow graph <p>A resource is a typed node with dependencies. Whether it's a Linux container or a construction work package doesn't matter \u2014 the patterns compute the same things: depth, ancestors, impact, deployment order, critical path.</p> <p>The PM sees schedule phases. The platform engineer sees deployment layers. Same code, same <code>cue export</code>.</p> <p>github.com/quicue/quicue.ca | demo | static API | docs | kg spec</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Model 3 resources, bind 2 providers, get a deployment plan. Takes 5 minutes.</p>"},{"location":"getting-started/#install-cue","title":"Install CUE","text":"<pre><code># macOS\nbrew install cue-lang/tap/cue\n\n# Linux (or see https://cuelang.org/docs/introduction/installation/)\ncurl -sSL https://github.com/cue-lang/cue/releases/latest/download/cue_v0.15.4_linux_amd64.tar.gz | tar xz\nsudo mv cue /usr/local/bin/\n\n# Verify\ncue version\n# cue version v0.15.4 or later\n</code></pre>"},{"location":"getting-started/#clone-the-repo","title":"Clone the repo","text":"<pre><code>git clone https://github.com/quicue/quicue.ca.git\ncd quicue.ca\n</code></pre>"},{"location":"getting-started/#define-your-resources","title":"Define your resources","text":"<p>Create a file called <code>my-infra.cue</code> in the repo root:</p> <pre><code>package datacenter\n\nimport (\n    \"quicue.ca/vocab\"\n    \"quicue.ca/patterns\"\n    \"quicue.ca/template/proxmox/patterns:proxmox_patterns\"\n    \"quicue.ca/template/powerdns/patterns:powerdns_patterns\"\n)\n\n// Three resources: a router, a DNS server that depends on it,\n// and a web server that depends on both.\n\n_resources: {\n    router: vocab.#Resource &amp; {\n        name:     \"router\"\n        \"@type\":  {Router: true}\n        ip:       \"198.51.100.1\"\n        ssh_user: \"admin\"\n    }\n    dns: vocab.#Resource &amp; {\n        name:         \"dns\"\n        \"@type\":      {LXCContainer: true, DNSServer: true}\n        depends_on:   {router: true}\n        host:         \"pve-node1\"\n        container_id: 100\n        ip:           \"198.51.100.10\"\n    }\n    web: vocab.#Resource &amp; {\n        name:         \"web\"\n        \"@type\":      {LXCContainer: true, WebServer: true}\n        depends_on:   {router: true, dns: true}\n        host:         \"pve-node1\"\n        container_id: 101\n        ip:           \"198.51.100.11\"\n    }\n}\n\n// Two providers: Proxmox manages LXC containers, PowerDNS manages DNS.\n\n_providers: {\n    proxmox: patterns.#ProviderDecl &amp; {\n        types:    {LXCContainer: true, VirtualMachine: true}\n        registry: proxmox_patterns.#ProxmoxRegistry\n    }\n    powerdns: patterns.#ProviderDecl &amp; {\n        types:    {DNSServer: true}\n        registry: powerdns_patterns.#PowerDNSRegistry\n    }\n}\n\n// Compute everything.\n\nexecution: patterns.#ExecutionPlan &amp; {\n    resources: _resources\n    providers: _providers\n}\n\noutput: {\n    summary:   execution.graph.metrics\n    topology:  execution.graph.topology\n    plan:      execution.plan\n}\n</code></pre>"},{"location":"getting-started/#validate","title":"Validate","text":"<pre><code>cue vet my-infra.cue\n</code></pre> <p>No output means it passed. If you misspell a field or leave <code>depends_on</code> pointing at a resource that doesn't exist, CUE tells you.</p>"},{"location":"getting-started/#see-what-you-built","title":"See what you built","text":"<pre><code># Dependency layers\ncue eval my-infra.cue -e output.topology\n\n# Deployment plan (ordered layers with gates)\ncue eval my-infra.cue -e output.plan\n\n# What commands does dns get?\ncue eval my-infra.cue -e execution.cluster.bound.dns.actions\n\n# Full JSON export\ncue export my-infra.cue -e output --out json\n</code></pre> <p>The <code>dns</code> resource has type <code>LXCContainer</code> and <code>DNSServer</code>. Proxmox matches on <code>LXCContainer</code> \u2014 so <code>dns</code> gets container lifecycle commands (<code>pct status 100</code>, <code>pct start 100</code>, etc.). PowerDNS matches on <code>DNSServer</code> \u2014 so <code>dns</code> also gets zone management commands. All resolved from the resource's fields at compile time.</p> <p><code>web</code> has type <code>LXCContainer</code> and <code>WebServer</code>. Proxmox matches on <code>LXCContainer</code>. PowerDNS doesn't match (no <code>DNSServer</code> type). <code>web</code> gets container commands only.</p> <p><code>router</code> has type <code>Router</code>. Neither provider matches. It gets no resolved commands \u2014 you'd need a VyOS or similar provider for that.</p>"},{"location":"getting-started/#what-breaks-if-dns-goes-down","title":"What breaks if DNS goes down?","text":"<pre><code>cue eval my-infra.cue -e '(patterns.#ImpactQuery &amp; {Graph: execution.graph, Target: \"dns\"})'\n</code></pre> <p>Answer: <code>web</code> is affected (it depends on <code>dns</code>). <code>router</code> is not (nothing depends on it from <code>dns</code>).</p>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<ul> <li>Add more resources and providers. See the datacenter example for a 30-resource setup with 29 providers.</li> <li>Write your own provider. The Template Guide walks through the process.</li> <li>Understand the architecture. The Architecture doc explains the four-layer model.</li> <li>Browse the pattern catalog. The Pattern Catalog lists every computation available.</li> </ul>"},{"location":"getting-started/#clean-up","title":"Clean up","text":"<p>Delete <code>my-infra.cue</code> when you're done \u2014 it was just for learning. Your real infrastructure definitions go in <code>examples/your-name/</code> or in a separate repo that imports <code>quicue.ca</code> as a CUE module.</p>"},{"location":"knowledge-graph/","title":"Knowledge Graph","text":"<p><code>quicue.ca/kg@v0</code> \u2014 CUE-native knowledge capture with compile-time validation.</p> <p>Projects accumulate knowledge that lives outside source code: why a technology was chosen, what approaches failed, which patterns recur. This knowledge typically scatters across wikis, chat logs, and individual memory. When it's lost, teams re-explore failed paths and make decisions without context.</p> <p>quicue-kg stores this knowledge as typed CUE data in a <code>.kb/</code> directory alongside your code. Each knowledge type gets its own subdirectory \u2014 decisions, patterns, insights, rejected \u2014 each an independent CUE package validated against its kg type. CUE's type system enforces structure \u2014 every rejected approach must record an alternative, every insight must cite evidence. Validation is <code>cue vet .</code> from each subdirectory. No database, no server.</p>"},{"location":"knowledge-graph/#quick-start","title":"Quick start","text":"<pre><code># Initialize a knowledge graph in your project\nkg init\n\n# Record a decision\nkg add decision\n# Edit the generated file, then validate\nkg vet\n\n# See what you've recorded\nkg index --summary\n</code></pre>"},{"location":"knowledge-graph/#installation","title":"Installation","text":"<p>Via GHCR (available now): <pre><code>export CUE_REGISTRY='quicue.ca=ghcr.io/quicue/cue-modules,registry.cue.works'\ncue mod tidy\n</code></pre></p> <p>Via local symlink (development): <pre><code>mkdir -p cue.mod/pkg/quicue.ca/kg\nln -s /path/to/quicue-kg/* cue.mod/pkg/quicue.ca/kg/\n</code></pre></p>"},{"location":"knowledge-graph/#types","title":"Types","text":""},{"location":"knowledge-graph/#core-core","title":"Core (<code>core/</code>)","text":"Type ID Pattern Purpose <code>#Decision</code> <code>ADR-NNN</code> Architecture decisions with mandatory rationale and consequences <code>#Pattern</code> \u2014 Reusable problem/solution pairs with cross-project tracking <code>#Insight</code> <code>INSIGHT-NNN</code> Validated discoveries with mandatory evidence and confidence level <code>#Rejected</code> <code>REJ-NNN</code> Failed approaches \u2014 must record what to do instead"},{"location":"knowledge-graph/#extensions-ext","title":"Extensions (<code>ext/</code>)","text":"Type Purpose <code>#Derivation</code> Data pipeline audit trails <code>#Workspace</code> Multi-repo topology mapping <code>#Context</code> Project identity and self-description <code>#SourceFile</code> Source artifact tracking with SHA256 and origin metadata <code>#CollectionProtocol</code> Repeatable data collection procedures (maps to prov:Plan) <code>#PipelineRun</code> Single pipeline execution event (maps to prov:Activity)"},{"location":"knowledge-graph/#aggregation-aggregate","title":"Aggregation (<code>aggregate/</code>)","text":"Type Purpose <code>#KGIndex</code> Computed summary, by_status, by_confidence views <code>#KGLint</code> Structural quality checks <code>#Provenance</code> PROV-O projection (decisions as provenance activities) <code>#DatasetEntry</code> DCAT projection (project as cataloged dataset) <code>#FederatedCatalog</code> DCAT catalog for federation results <code>#Annotations</code> Web Annotation projection (insights as annotations) <code>#Prolog</code> Prolog facts + inference rules <code>#Datalog</code> Souffl\u00e9-compatible Datalog (guaranteed termination) <code>#NTriples</code> N-Triples \u2014 one triple per line, greppable RDF <code>#Turtle</code> Turtle \u2014 human-readable prefixed RDF <code>#SKOSTaxonomy</code> SKOS concept scheme from pattern categories <p>All aggregate types produce W3C-compatible linked data. See Linked Data for the full projection reference.</p>"},{"location":"knowledge-graph/#what-makes-this-different","title":"What makes this different","text":"<ol> <li> <p>Knowledge conflicts are type errors. If two teams assert contradictory facts, CUE unification fails at build time \u2014 not silently at read time.</p> </li> <li> <p>Federation without infrastructure. Merging knowledge across projects is a CUE import, not a service call. <code>cue vet</code> catches conflicts.</p> </li> <li> <p>Progressive refinement. CUE's type lattice only narrows, never broadens. A field constrained to <code>\"high\" | \"medium\" | \"low\"</code> can't silently accept <code>\"maybe\"</code>.</p> </li> <li> <p>Schema evolution as a quality ratchet. Adding a required field to <code>#Decision</code> makes every existing entry without it a validation error.</p> </li> <li> <p>Computed indexes. Summary views (<code>by_status</code>, <code>by_confidence</code>) are CUE comprehensions \u2014 always in sync because they're derived.</p> </li> </ol>"},{"location":"knowledge-graph/#cli","title":"CLI","text":"<pre><code>Usage: kg &lt;command&gt; [args...]\n\nCommands:\n  init              Scaffold .kb/ directory with imports\n  add &lt;type&gt;        Create new entry (decision|pattern|insight|rejected)\n  vet               Validate .kb/ content\n  index [--full]    Export aggregated index as JSON\n  query &lt;expr&gt;      Query via CUE expression\n  lint              Knowledge quality checks\n  settle            Check for conflicts, coverage gaps, referential integrity\n  diff [ref]        Semantic changelog since git ref\n  link &lt;a&gt; &lt;b&gt;      Cross-reference two entries\n  graph [--dot]     Export relationships as JSON or DOT\n  fed &lt;dirs...&gt;     Federate multiple .kb/ directories\n</code></pre>"},{"location":"knowledge-graph/#specification","title":"Specification","text":"<p>The formal specification covers directory layout, type constraints, aggregation semantics, and the federation protocol:</p> <p>Read the specification \u2192</p> <p>JSON-LD vocabulary context: kg.quicue.ca/context.jsonld</p> <p>Source: github.com/quicue/quicue-kg</p>"},{"location":"linked-data/","title":"Linked Data","text":"<p>Model it in CUE. Validate by unification. Export to whatever the world expects.</p> <p>quicue.ca produces W3C-compatible linked data from two layers: the infrastructure layer models what exists (resources, dependencies, operations), and the knowledge layer captures why it exists (decisions, patterns, insights). Both export to standard vocabularies. Both validate by <code>cue vet</code>.</p>"},{"location":"linked-data/#two-layers-one-iri-space","title":"Two layers, one IRI space","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Infrastructure layer (quicue.ca/patterns)               \u2502\n\u2502                                                          \u2502\n\u2502  vocab/context.cue          JSON-LD @context             \u2502\n\u2502  patterns/shacl.cue         SHACL shapes                 \u2502\n\u2502  patterns/dcat.cue          DCAT 3 data catalog          \u2502\n\u2502  patterns/ntriples.cue      N-Triples (greppable RDF)    \u2502\n\u2502  patterns/odrl.cue          ODRL access policies         \u2502\n\u2502  ou/hydra.cue               Hydra API documentation      \u2502\n\u2502  ou/activitystreams.cue     AS2 change feed              \u2502\n\u2502  ou/ldes.cue                LDES event stream            \u2502\n\u2502  examples/*/jsonld           JSON-LD graph export         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Knowledge layer (quicue.ca/kg)                          \u2502\n\u2502                                                          \u2502\n\u2502  aggregate/provenance.cue   PROV-O audit trails          \u2502\n\u2502  aggregate/catalog.cue      DCAT dataset registration    \u2502\n\u2502  aggregate/annotation.cue   Web Annotation insights      \u2502\n\u2502  aggregate/skos.cue         SKOS pattern taxonomy        \u2502\n\u2502  aggregate/turtle.cue       Turtle RDF                   \u2502\n\u2502  aggregate/ntriples.cue     N-Triples (greppable RDF)    \u2502\n\u2502  aggregate/prolog.cue       Prolog inference rules        \u2502\n\u2502  aggregate/datalog.cue      Datalog (guaranteed halt)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The layers share namespace wiring. <code>vocab/context.cue</code> includes <code>prov:</code>, <code>dcat:</code>, <code>oa:</code>, <code>as:</code>, and <code>sh:</code> prefixes \u2014 both layers export to the same IRI space. Inside CUE, comprehensions precompute every query. Outside CUE, the shared IRIs let a SPARQL endpoint join infrastructure state with the decisions that shaped it.</p>"},{"location":"linked-data/#infrastructure-projections","title":"Infrastructure projections","text":""},{"location":"linked-data/#json-ld-graph","title":"JSON-LD graph","text":"<p>Every resource exports as a JSON-LD node with typed IRIs and dependency edges:</p> <pre><code>cue export ./examples/datacenter/ -e jsonld --out json\n</code></pre> <p>The <code>@context</code> from <code>vocab/context.cue</code> maps CUE field names to <code>quicue:</code> namespace IRIs.</p>"},{"location":"linked-data/#shacl-shapes","title":"SHACL shapes","text":"<p><code>patterns/shacl.cue</code> generates <code>sh:NodeShape</code> definitions from the type registry. External consumers can validate your JSON-LD exports without CUE:</p> <pre><code>cue export -e shapes.graph --out json &gt; shapes.jsonld\n</code></pre>"},{"location":"linked-data/#hydra-api","title":"Hydra API","text":"<p><code>ou/hydra.cue</code> generates self-describing API documentation. Each resource type becomes a <code>hydra:Class</code> with <code>supportedOperation</code> and <code>supportedProperty</code>.</p>"},{"location":"linked-data/#dcat-3-catalog","title":"DCAT 3 catalog","text":"<p><code>patterns/dcat.cue</code> generates a DCAT 3 data catalog from any <code>#InfraGraph</code>. Each resource becomes a <code>dcat:Dataset</code> entry, with optional <code>dcat:DataService</code> endpoints for SPARQL and LDES:</p> <pre><code>cue export ./examples/datacenter/ -e dcat_catalog --out json\n</code></pre>"},{"location":"linked-data/#n-triples","title":"N-Triples","text":"<p><code>patterns/ntriples.cue</code> serializes any <code>#InfraGraph</code> as N-Triples \u2014 one triple per line, loadable into any triplestore. Combines with kg N-Triples for cross-layer SPARQL queries:</p> <pre><code>cue export ./examples/datacenter/ -e sparql_export --out text &gt; data.nt\n</code></pre>"},{"location":"linked-data/#odrl-access-policies","title":"ODRL access policies","text":"<p><code>patterns/odrl.cue</code> generates ODRL 2.2 machine-readable access policies. Policies declare who can perform what action on which resources \u2014 enforcement is external (Cloudflare Access, Caddy, etc.):</p> <pre><code>cue export -e policy.policy --out json &gt; policy.jsonld\n</code></pre>"},{"location":"linked-data/#ldes-event-stream","title":"LDES event stream","text":"<p><code>ou/ldes.cue</code> generates LDES event streams via the TREE specification. Each graph snapshot becomes an immutable event in an append-only stream \u2014 static JSON-LD files on any HTTP server, no streaming infrastructure needed:</p> <pre><code>cue export -e event.event --out json &gt; ldes/event.jsonld\n</code></pre>"},{"location":"linked-data/#activitystreams-20","title":"ActivityStreams 2.0","text":"<p><code>ou/activitystreams.cue</code> maps operator sessions to AS2 activities for infrastructure change feeds.</p>"},{"location":"linked-data/#knowledge-projections","title":"Knowledge projections","text":"<p>All knowledge projections live in <code>quicue.ca/kg</code>'s <code>aggregate/</code> package. They share the same input contract \u2014 a <code>#KGIndex</code> computed from <code>.kb/</code> files \u2014 and emit structured output.</p> <p>CUE is the source of truth. You never edit the RDF \u2014 you edit CUE and re-export.</p>"},{"location":"linked-data/#rdf-serializations","title":"RDF serializations","text":"<p>Three wire formats for the same data model:</p> Format Best for Export N-Triples <code>grep</code>, <code>sort</code>, <code>diff</code>, bulk triplestore loading <code>cue export .kb/ -e _ntriples.triples --out text</code> Turtle Human reading, SPARQL endpoint import <code>cue export .kb/ -e _turtle.document --out text</code> JSON-LD Web APIs, browser consumption <code>cue export .kb/ -e _provenance.graph --out json</code>"},{"location":"linked-data/#semantic-vocabularies","title":"Semantic vocabularies","text":"Projection Standard Purpose Export PROV-O W3C Provenance Decision audit trails <code>_provenance.graph</code> DCAT Data Catalog Project catalog registration <code>_catalog.dataset</code> Web Annotation W3C Annotation Insights as annotations <code>_annotations.graph</code> SKOS Knowledge Org Pattern taxonomy <code>_taxonomy.graph</code>"},{"location":"linked-data/#logic-programming","title":"Logic programming","text":"<p>Facts and inference rules make knowledge computable:</p> Projection Runtime Terminates? Best for Prolog SWI-Prolog No (Turing-complete) Interactive exploration Datalog Souffl\u00e9 Yes (guaranteed) CI automation, large datasets <p>Both include 6 inference rules: transitive provenance, trust levels, authority ranking, shared patterns, active decisions, and actionable insights.</p> <pre><code># Prolog \u2014 interactive exploration\ncue export .kb/ -e _prolog.program --out text &gt; kb.pl\nswipl -l kb.pl\n\n# Datalog \u2014 compiles to C++, guaranteed termination\ncue export .kb/ -e _datalog.program --out text &gt; kb.dl\nsouffle kb.dl\n</code></pre>"},{"location":"linked-data/#cross-layer-queries","title":"Cross-layer queries","text":"<p>The infrastructure graph and knowledge graph share the same IRI space:</p> <pre><code>PREFIX kg: &lt;https://quicue.ca/kg#&gt;\nPREFIX quicue: &lt;https://quicue.ca/vocab#&gt;\nPREFIX prov: &lt;http://www.w3.org/ns/prov#&gt;\n\nSELECT ?decision ?resource ?deps WHERE {\n  ?decision a kg:Decision ; prov:startedAtTime ?date .\n  ?resource quicue:depends_on ?dep .\n}\nGROUP BY ?decision ?resource\nHAVING (COUNT(?dep) &gt; 3)\n</code></pre>"},{"location":"linked-data/#namespaces","title":"Namespaces","text":"Prefix IRI Layer <code>quicue:</code> <code>https://quicue.ca/vocab#</code> Infrastructure <code>kg:</code> <code>https://quicue.ca/kg#</code> Knowledge <code>prov:</code> <code>http://www.w3.org/ns/prov#</code> Both <code>dcat:</code> <code>http://www.w3.org/ns/dcat#</code> Both <code>oa:</code> <code>http://www.w3.org/ns/oa#</code> Knowledge <code>skos:</code> <code>http://www.w3.org/2004/02/skos/core#</code> Knowledge <code>sh:</code> <code>http://www.w3.org/ns/shacl#</code> Infrastructure <code>hydra:</code> <code>http://www.w3.org/ns/hydra/core#</code> Infrastructure <code>as:</code> <code>https://www.w3.org/ns/activitystreams#</code> Infrastructure <code>odrl:</code> <code>http://www.w3.org/ns/odrl/2/</code> Infrastructure <code>tree:</code> <code>https://w3id.org/tree#</code> Infrastructure <code>ldes:</code> <code>https://w3id.org/ldes#</code> Infrastructure <code>dcterms:</code> <code>http://purl.org/dc/terms/</code> Both <p>JSON-LD contexts: <code>quicue:</code> | <code>kg:</code></p>"},{"location":"linked-data/#choosing-a-format","title":"Choosing a format","text":"I want to... Use Describe resources as linked data JSON-LD graph Validate RDF externally SHACL shapes Self-describing API for frontends Hydra Feed changes to subscribers ActivityStreams Publish immutable snapshots LDES event stream Declare access policies ODRL Decision audit trails PROV-O Load into a triplestore Turtle or N-Triples Process with unix tools N-Triples (infrastructure or knowledge) Browse patterns as taxonomy SKOS Query provenance chains Prolog or Datalog Automated CI checks Datalog Register in a data catalog DCAT 3"},{"location":"patterns/","title":"Pattern Catalog","text":"<p>Reference for all computational patterns in <code>quicue.ca/patterns@v0</code>. Every pattern is a CUE definition that takes typed inputs and produces computed outputs. Patterns compose \u2014 most accept <code>Graph: #InfraGraph</code> and can be combined freely.</p> <p>Identifier safety: All resource names, <code>@type</code> keys, and <code>depends_on</code> keys are constrained to ASCII via <code>#SafeID</code> and <code>#SafeLabel</code> in <code>vocab/resource.cue</code>. Patterns assume safe identifiers \u2014 <code>cue vet</code> enforces the constraints at compile time.</p>"},{"location":"patterns/#schema-index","title":"Schema Index","text":"<ul> <li><code>#InfraGraph</code></li> <li><code>#BindCluster</code></li> <li><code>#ExecutionPlan</code></li> <li><code>#ImpactQuery</code></li> <li><code>#BlastRadius</code></li> <li><code>#SinglePointsOfFailure</code></li> <li><code>#CriticalityRank</code></li> <li><code>#HealthStatus</code></li> <li><code>#RollbackPlan</code></li> <li><code>#DeploymentPlan</code></li> <li><code>#TOONExport</code></li> <li><code>#ExportGraph</code></li> <li><code>#ValidateGraph</code></li> <li><code>#ValidateTypes</code></li> <li><code>#GroupByType</code></li> <li><code>#GraphMetrics</code></li> <li><code>#ImmediateDependents</code></li> <li><code>#DependencyChain</code></li> <li><code>#CycleDetector</code></li> <li><code>#ConnectedComponents</code></li> <li><code>#Subgraph</code></li> <li><code>#GraphDiff</code></li> <li><code>#CriticalPath</code></li> <li><code>#ComplianceCheck</code></li> <li><code>#LifecyclePhasesSKOS</code></li> </ul>"},{"location":"patterns/#groups","title":"Groups","text":""},{"location":"patterns/#graph-construction","title":"Graph construction","text":"<p><code>#InfraGraph</code>, <code>#ValidateGraph</code>, <code>#CycleDetector</code>, <code>#ConnectedComponents</code>, <code>#Subgraph</code>, <code>#GraphDiff</code></p>"},{"location":"patterns/#impact-analysis","title":"Impact analysis","text":"<p><code>#ImpactQuery</code>, <code>#BlastRadius</code>, <code>#CompoundRiskAnalysis</code>, <code>#GraphMetrics</code>, <code>#ImmediateDependents</code>, <code>#DependencyChain</code></p>"},{"location":"patterns/#ranking-and-classification","title":"Ranking and classification","text":"<p><code>#CriticalityRank</code>, <code>#RiskScore</code>, <code>#GroupByType</code>, <code>#SinglePointsOfFailure</code>, <code>#SPOFWithRedundancy</code></p>"},{"location":"patterns/#health-and-operations","title":"Health and operations","text":"<p><code>#HealthStatus</code>, <code>#DeploymentPlan</code>, <code>#RollbackPlan</code></p>"},{"location":"patterns/#compliance","title":"Compliance","text":"<p><code>#ComplianceCheck</code>, <code>#ComplianceRule</code></p>"},{"location":"patterns/#binding-and-execution","title":"Binding and execution","text":"<p><code>#BindCluster</code>, <code>#ExecutionPlan</code>, <code>#ResolveTemplate</code></p>"},{"location":"patterns/#visualization","title":"Visualization","text":"<p><code>#GraphvizDiagram</code>, <code>#MermaidDiagram</code>, <code>#VizData</code>, <code>#DependencyMatrix</code></p>"},{"location":"patterns/#export-formats","title":"Export formats","text":"<p><code>#TOONExport</code>, <code>#OpenAPISpec</code>, <code>#SHACLShapes</code>, <code>#JustfileProjection</code>, <code>#ExportGraph</code></p>"},{"location":"patterns/#lifecycle","title":"Lifecycle","text":"<p><code>#BootstrapPlan</code>, <code>#DriftReport</code>, <code>#SmokeTest</code>, <code>#DeploymentLifecycle</code></p>"},{"location":"patterns/#critical-path","title":"Critical path","text":"<p><code>#CriticalPath</code>, <code>#LifecyclePhasesSKOS</code></p> <p>See KB Patterns for the 16 validated problem/solution pairs that inform these schemas.</p>"},{"location":"templates/","title":"Template Authoring Guide","text":"<p>29 provider templates across 13 categories. Each template teaches the system how to manage a specific platform \u2014 what resource types it serves, what actions it can perform, and how those actions translate to concrete commands.</p>"},{"location":"templates/#categories","title":"Categories","text":"Category Providers compute <code>proxmox</code>, <code>govc</code>, <code>powercli</code>, <code>kubevirt</code> container <code>docker</code>, <code>incus</code>, <code>k3d</code>, <code>kubectl</code>, <code>argocd</code> cicd <code>dagger</code>, <code>gitlab</code> networking <code>vyos</code>, <code>caddy</code>, <code>nginx</code> dns <code>cloudflare</code>, <code>powerdns</code>, <code>technitium</code> identity <code>vault</code>, <code>keycloak</code> database <code>postgresql</code> dcim <code>netbox</code> provisioning <code>foreman</code> automation <code>ansible</code>, <code>awx</code> monitoring <code>zabbix</code> iac <code>terraform</code>, <code>opentofu</code> backup <code>restic</code>, <code>pbs</code>"},{"location":"templates/#directory-structure","title":"Directory Structure","text":"<pre><code>template/&lt;name&gt;/\n  meta/meta.cue          # Provider metadata and type matching\n  patterns/&lt;name&gt;.cue    # Action registry\n  examples/demo.cue      # Working example\n  README.md\n</code></pre>"},{"location":"templates/#parameter-binding","title":"Parameter binding","text":"<p>Each parameter declares <code>from_field</code> \u2014 the resource field it binds to:</p> <code>from_field</code> Resolves from Example value <code>\"ip\"</code> <code>resource.ip</code> <code>\"198.51.100.211\"</code> <code>\"host\"</code> <code>resource.host</code> <code>\"pve-alpha\"</code> <code>\"container_id\"</code> <code>resource.container_id</code> <code>101</code> <code>\"ssh_user\"</code> <code>resource.ssh_user</code> <code>\"root\"</code> <p>Rules:</p> <ul> <li>If a required parameter's field is missing from the resource, the entire action is silently omitted.</li> <li>Optional parameters (<code>required: false</code>) with <code>default</code> values use the default when the field is absent.</li> <li>All values are stringified for template substitution.</li> <li>Up to 8 parameters per action (limitation of <code>#ResolveTemplate</code>).</li> </ul>"},{"location":"templates/#conventions","title":"Conventions","text":"<ol> <li>Use generic field names. <code>host</code> not <code>node</code>, <code>container_id</code> not <code>lxcid</code>.</li> <li>One registry per provider. Name it <code>#&lt;Name&gt;Registry</code>.</li> <li>Idempotent by default. Mark read-only actions as <code>idempotent: true</code>. Mark state-changing actions as <code>destructive: true</code>.</li> <li>SSH wrapping. For remote actions, use <code>ssh {host} '&lt;command&gt;'</code> in the template.</li> <li>Package naming. <code>meta/meta.cue</code> uses <code>package meta</code>. <code>patterns/&lt;name&gt;.cue</code> uses <code>package patterns</code>. <code>examples/demo.cue</code> uses <code>package demo</code>.</li> </ol>"},{"location":"decisions/","title":"Architecture Decisions","text":"<p>14 architecture decision records (ADRs).</p> ID Title Status Date ADR-001 Three-layer architecture: definition, template, value accepted 2025-01-01 ADR-002 Struct-as-set: {key: true} over arrays for types and dependencies accepted 2025-01-01 ADR-003 Compile-time provider binding: all parameters resolve at cue eval accepted 2025-06-01 ADR-004 Layer 4 interaction: ou/ scopes #ExecutionPlan by role, type, name, and layer accepted 2026-01-31 ADR-005 Charter: constraint schema with computed gap analysis accepted 2026-02-17 ADR-006 Public showcase data sourced exclusively from example datacenter accepted 2026-02-18 ADR-007 CUE conditional branches for optional charter scope fields accepted 2026-02-18 ADR-008 Domain-general framing: 'things that depend on other things' accepted 2026-02-18 ADR-009 SPARQL is external federation only \u2014 CUE comprehensions are the query layer accepted 2026-02-18 ADR-010 Game design projects tracked separately from quicue.ca accepted 2026-02-18 ADR-011 lacuene is not a downstream consumer accepted 2026-02-18 ADR-012 Static-first showcase: all public surfaces on Cloudflare Pages accepted 2026-02-18 ADR-013 Lifecycle management in patterns/, not a separate orche/ package accepted 2026-02-19 ADR-014 ASCII-safe identifiers (#SafeID, #SafeLabel) on all graph surfaces accepted 2026-02-19"},{"location":"decisions/adr-001/","title":"ADR-001: Three-layer architecture: definition, template, value","text":"Field Value Status accepted Date 2025-01-01"},{"location":"decisions/adr-001/#context","title":"Context","text":"<p>Infrastructure modeling requires separating universal concepts from platform-specific implementations from concrete instances.</p>"},{"location":"decisions/adr-001/#decision","title":"Decision","text":"<p>Use a 3-layer architecture: vocab/ + patterns/ (definition), template/*/ (template), examples/ (value). Each layer constrains the next via CUE unification.</p>"},{"location":"decisions/adr-001/#rationale","title":"Rationale","text":"<p>CUE's unification model naturally supports layered constraints. Definitions are provider-agnostic, templates add platform specifics, values bind concrete data. Violations are compile-time errors.</p>"},{"location":"decisions/adr-001/#consequences","title":"Consequences","text":"<ul> <li>Every provider must implement interfaces from patterns/</li> <li>Generic field names map to platform-specific commands</li> <li>New providers add template/*/ modules without touching definition or value layers</li> </ul>"},{"location":"decisions/adr-002/","title":"ADR-002: Struct-as-set: {key: true} over arrays for types and dependencies","text":"Field Value Status accepted Date 2025-01-01"},{"location":"decisions/adr-002/#context","title":"Context","text":"<p>Resources need type membership and dependency declarations. Arrays require list.Contains (O(n)) and produce duplicates on unification.</p>"},{"location":"decisions/adr-002/#decision","title":"Decision","text":"<p>Use struct-as-set pattern: {@type: {DNSServer: true, LXCContainer: true}} and {depends_on: {dns: true}}. O(1) membership, clean CUE unification, no duplicates.</p>"},{"location":"decisions/adr-002/#rationale","title":"Rationale","text":"<p>CUE unifies structs by merging keys. {A: true} &amp; {B: true} = {A: true, B: true}. Arrays would need explicit dedup. Struct keys are unique by construction.</p>"},{"location":"decisions/adr-002/#consequences","title":"Consequences","text":"<ul> <li>All @type fields use {[string]: true} not [...string]</li> <li>JSON-LD export converts to arrays: [for t, _ in @type {t}]</li> <li>Provider matching uses resource[@type][providerType] != | (O(1))</li> </ul>"},{"location":"decisions/adr-003/","title":"ADR-003: Compile-time provider binding: all parameters resolve at cue eval","text":"Field Value Status accepted Date 2025-06-01"},{"location":"decisions/adr-003/#context","title":"Context","text":"<p>Provider templates define commands with parameters ({host}, {container_id}). These could be resolved at runtime or at CUE evaluation time.</p>"},{"location":"decisions/adr-003/#decision","title":"Decision","text":""},{"location":"decisions/adr-003/#bindcluster-matches-providers-to-resources-by-type-overlap-then-resolvetemplate-substitutes-all-param-placeholders-from-resource-fields-at-cue-eval-time","title":"BindCluster matches providers to resources by @type overlap, then #ResolveTemplate substitutes all {param} placeholders from resource fields at cue eval time.","text":""},{"location":"decisions/adr-003/#rationale","title":"Rationale","text":"<p>Compile-time resolution means CUE catches missing fields before anything runs. A missing container_id is a type error, not a runtime 'undefined variable'.</p>"},{"location":"decisions/adr-003/#consequences","title":"Consequences","text":"<ul> <li>Resources must declare all fields their bound providers reference</li> <li>Provider templates use {param} syntax with explicit from_field bindings</li> <li>The output of cue export is fully resolved \u2014 ready to execute</li> <li>No runtime templating engine needed</li> </ul>"},{"location":"decisions/adr-004/","title":"ADR-004: Layer 4 interaction: ou/ scopes #ExecutionPlan by role, type, name, and layer","text":"Field Value Status accepted Date 2026-01-31"},{"location":"decisions/adr-004/#context","title":"Context","text":"<p>The 3-layer model produces complete execution plans. Different operators need narrowed views: ops sees everything, dev sees DNS only, readonly sees info actions only.</p>"},{"location":"decisions/adr-004/#decision","title":"Decision","text":"<p>Add ou/ package (Layer 4) with #InteractionCtx that narrows #ExecutionPlan via CUE comprehensions.</p>"},{"location":"decisions/adr-004/#rationale","title":"Rationale","text":"<p>CUE comprehensions are the natural filtering mechanism \u2014 no runtime logic, just struct narrowing.</p>"},{"location":"decisions/adr-004/#consequences","title":"Consequences","text":"<ul> <li>Architecture becomes 4 layers: definition, template, value, interaction</li> <li> </li> <li>Operator roles use struct-as-set for visible_categories</li> <li>Hydra JSON-LD generation is explicit: consumer passes scoped view to #ApiDocumentation</li> </ul>"},{"location":"decisions/adr-004/#interactionctx-consumes-executionplan-no-direct-dependency-on-vocab-or-template","title":"InteractionCtx consumes #ExecutionPlan \u2014 no direct dependency on vocab/ or template/","text":""},{"location":"decisions/adr-005/","title":"ADR-005: Charter: constraint schema with computed gap analysis","text":"Field Value Status accepted Date 2026-02-17"},{"location":"decisions/adr-005/#context","title":"Context","text":"<p>Downstream projects each have verify.cue files with identical patterns. The pattern is ad-hoc \u2014 no shared vocabulary, no intermediate checkpoints.</p>"},{"location":"decisions/adr-005/#decision","title":"Decision","text":"<p>Charter defines #Charter (scope + gates), #Gate (DAG checkpoint), #GapAnalysis (computed missing resources, types, gate status), and #Milestone (single gate evaluation).</p>"},{"location":"decisions/adr-005/#rationale","title":"Rationale","text":"<p>Raw cue vet errors are unstructured text. #GapAnalysis produces typed CUE output consumable programmatically.</p>"},{"location":"decisions/adr-005/#consequences","title":"Consequences","text":"<ul> <li>Downstream projects use #GapAnalysis to compute structured backlog from charter + graph</li> <li>Gate DAG subsumes linear phases \u2014 a chain is a degenerate DAG</li> <li> </li> <li>Gap analysis output is typed and exportable as JSON</li> </ul>"},{"location":"decisions/adr-005/#milestone-provides-focused-per-gate-evaluation-without-full-gap-analysis","title":"Milestone provides focused per-gate evaluation without full gap analysis","text":""},{"location":"decisions/adr-006/","title":"ADR-006: Public showcase data sourced exclusively from example datacenter","text":"Field Value Status accepted Date 2026-02-18"},{"location":"decisions/adr-006/#context","title":"Context","text":"<p>Public surfaces were originally built from production infrastructure data containing real 172.20.x.x IPs.</p>"},{"location":"decisions/adr-006/#decision","title":"Decision","text":"<p>All public-facing data is generated from examples/datacenter/ which uses RFC 5737 TEST-NET IPs (198.51.100.x). CI validates no real IPs leak.</p>"},{"location":"decisions/adr-006/#rationale","title":"Rationale","text":"<p>A single source of safe data eliminates the risk of production IP leakage.</p>"},{"location":"decisions/adr-006/#consequences","title":"Consequences","text":"<ul> <li>All public surfaces serve data from examples/datacenter/ only</li> <li>CI validates no 172.x.x.x IPs in generated files</li> <li>Deploy scripts are parameterized \u2014 no hardcoded infrastructure hostnames</li> <li>Production data stays behind CF Access on apercue.ca surfaces</li> </ul>"},{"location":"decisions/adr-007/","title":"ADR-007: CUE conditional branches for optional charter scope fields","text":"Field Value Status accepted Date 2026-02-18"},{"location":"decisions/adr-007/#context","title":"Context","text":"<p>Charter #GapAnalysis used count_satisfied: true as a default \u2014 in CUE, this is a hard constraint, not a default.</p>"},{"location":"decisions/adr-007/#decision","title":"Decision","text":"<p>Use mutually exclusive conditional branches with a bool type constraint instead of a hard true default.</p>"},{"location":"decisions/adr-007/#rationale","title":"Rationale","text":"<p>CUE unification makes foo: true into an immutable constraint. The only way to conditionally set a field is via mutually exclusive if branches.</p>"},{"location":"decisions/adr-007/#consequences","title":"Consequences","text":"<ul> <li>depth_satisfied and count_satisfied now use bool type + conditional branches</li> <li>Charter gap analysis works correctly when graph has fewer resources than scope requires</li> <li>cue vet on public fields catches conflicts that hidden-field tests miss</li> </ul>"},{"location":"decisions/adr-008/","title":"ADR-008: Domain-general framing: 'things that depend on other things'","text":"Field Value Status accepted Date 2026-02-18"},{"location":"decisions/adr-008/#context","title":"Context","text":"<p>Public surfaces framed quicue.ca as 'infrastructure as typed dependency graphs.' This undersells the framework.</p>"},{"location":"decisions/adr-008/#decision","title":"Decision","text":"<p>Frame as 'CUE framework for modeling any domain where things depend on other things.' The entry point is two fields: @type and depends_on.</p>"},{"location":"decisions/adr-008/#rationale","title":"Rationale","text":"<p>The core requirement is: typed nodes with directed dependency edges. That's domain-independent.</p>"},{"location":"decisions/adr-008/#consequences","title":"Consequences","text":"<ul> <li>GitHub profile, repo descriptions, and docs all use domain-general language</li> <li>Downstream table replaces domain-specific prose as the credibility signal</li> <li>'Infrastructure' appears only when describing the IT domain specifically</li> </ul>"},{"location":"decisions/adr-009/","title":"ADR-009: SPARQL is external federation only \u2014 CUE comprehensions are the query layer","text":"Field Value Status accepted Date 2026-02-18"},{"location":"decisions/adr-009/#context","title":"Context","text":"<p>Docs framed SPARQL as a primary query mechanism. This misrepresents the architecture.</p>"},{"location":"decisions/adr-009/#decision","title":"Decision","text":"<p>SPARQL is for external federation only. Inside CUE, comprehensions ARE the query layer.</p>"},{"location":"decisions/adr-009/#rationale","title":"Rationale","text":"<p>CUE unification IS a query engine for the closed world. SPARQL adds runtime dependency that doesn't exist.</p>"},{"location":"decisions/adr-009/#consequences","title":"Consequences","text":"<ul> <li>Oxigraph reclassified from 'optional infrastructure' to 'external federation only'</li> <li>Docs distinguish 'inside CUE' (comprehensions) from 'outside CUE' (SPARQL/triplestore)</li> <li>Profile README no longer implies SPARQL is the primary query method</li> </ul>"},{"location":"decisions/adr-010/","title":"ADR-010: Game design projects tracked separately from quicue.ca","text":"Field Value Status accepted Date 2026-02-18"},{"location":"decisions/adr-010/#context","title":"Context","text":"<p>mud-futurama and fing-mod use quicue.ca/kg but listing them as downstream dilutes the message.</p>"},{"location":"decisions/adr-010/#decision","title":"Decision","text":"<p>Remove game design projects from quicue.ca's downstream registry and all public documentation.</p>"},{"location":"decisions/adr-010/#rationale","title":"Rationale","text":"<p>Including game projects alongside CMHC retrofit and production datacenter management undermines credibility.</p>"},{"location":"decisions/adr-010/#consequences","title":"Consequences","text":"<ul> <li>mud-futurama and fing-mod removed from .kb/downstream.cue</li> <li>Downstream count: 4 projects across 4 domains</li> <li>Game projects maintain their own .kb/ independently</li> <li>No game/MUD references on any quicue.ca public surface</li> </ul>"},{"location":"decisions/adr-011/","title":"ADR-011: lacuene is not a downstream consumer","text":"Field Value Status accepted Date 2026-02-18"},{"location":"decisions/adr-011/#context","title":"Context","text":"<p>lacuene was listed as a downstream project but does not import quicue.ca/patterns or quicue.ca/vocab.</p>"},{"location":"decisions/adr-011/#decision","title":"Decision","text":"<p>Remove lacuene from all downstream claims. Only projects that import quicue.ca are listed.</p>"},{"location":"decisions/adr-011/#rationale","title":"Rationale","text":"<p>Listing a project that doesn't use the framework as a consumer is inaccurate.</p>"},{"location":"decisions/adr-011/#consequences","title":"Consequences","text":"<ul> <li>lacuene removed from README, docs, and all docs</li> <li>Downstream criteria: must import quicue.ca/patterns or quicue.ca/vocab</li> <li>'Biomedical research' removed from domain list</li> </ul>"},{"location":"decisions/adr-012/","title":"ADR-012: Static-first showcase: all public surfaces on Cloudflare Pages","text":"Field Value Status accepted Date 2026-02-18"},{"location":"decisions/adr-012/#context","title":"Context","text":"<p>Public showcases were served by Caddy behind a Cloudflare Tunnel. The tunnel depends on port 7844 which ISP equipment blocks.</p>"},{"location":"decisions/adr-012/#decision","title":"Decision","text":"<p>Deploy all static showcases to Cloudflare Pages. The static API serves the same endpoints as pre-computed JSON files.</p>"},{"location":"decisions/adr-012/#rationale","title":"Rationale","text":"<p>CUE comprehensions pre-compute all possible API responses at eval time. If every answer is known at build time, a web server adds latency without capability.</p>"},{"location":"decisions/adr-012/#consequences","title":"Consequences","text":"<ul> <li>7 CF Pages projects replace Caddy vhosts</li> <li>All API examples use GET (POST returns 405 on static hosting)</li> <li>Tunnel only needed for dynamic services: MUDs, live execution</li> <li>Deploy workflow: cue export, build-static-api.sh, wrangler pages deploy</li> </ul>"},{"location":"decisions/adr-013/","title":"ADR-013: Lifecycle management in patterns/, not a separate orche/ package","text":"Field Value Status accepted Date 2026-02-19"},{"location":"decisions/adr-013/#context","title":"Context","text":"<p>boot/ and orche/ reference packages that don't exist. patterns/ already has lifecycle-adjacent definitions.</p>"},{"location":"decisions/adr-013/#decision","title":"Decision","text":"<p>Absorb lifecycle management into patterns/lifecycle.cue. No separate orche/ package.</p>"},{"location":"decisions/adr-013/#rationale","title":"Rationale","text":"<p>CUE's strength is type composition via unification. Types that compose belong together.</p>"},{"location":"decisions/adr-013/#consequences","title":"Consequences","text":"<ul> <li>patterns/lifecycle.cue created with #BootstrapPlan, #DriftReport, #SmokeTest, #DeploymentLifecycle</li> <li>boot/ types refactored into patterns/</li> <li>examples/drift-detection/ updated to import patterns/ instead of orche/</li> <li>No orche/ module to publish or version separately</li> </ul>"},{"location":"decisions/adr-014/","title":"ADR-014: ASCII-safe identifiers (#SafeID, #SafeLabel) on all graph surfaces","text":"Field Value Status accepted Date 2026-02-19"},{"location":"decisions/adr-014/#context","title":"Context","text":"<p>CUE unification treats string values as opaque byte sequences. Cyrillic 'a' and Latin 'a' are different CUE values that look identical.</p>"},{"location":"decisions/adr-014/#decision","title":"Decision","text":"<p>Constrain all graph identifiers to ASCII via regex. #SafeID for resource names, #SafeLabel for type keys.</p>"},{"location":"decisions/adr-014/#rationale","title":"Rationale","text":"<p>Constraining identifiers to ASCII eliminates the entire class of unicode-based confusion attacks.</p>"},{"location":"decisions/adr-014/#consequences","title":"Consequences","text":"<ul> <li>All resource names, @type keys, depends_on keys must be ASCII</li> <li>patterns/graph.cue defines hidden mirrors (#SafeID, #SafeLabel)</li> <li>boot/resource.cue uses inline regex (no cross-package hidden field access)</li> <li>Downstream repos inherit constraints via quicue.ca symlink</li> <li>apercue.ca has identical constraints \u2014 both layers enforce independently</li> </ul>"},{"location":"example/","title":"Example Output","text":"<p>17 working examples demonstrating quicue.ca patterns from minimal to production-scale.</p>"},{"location":"example/#examples","title":"Examples","text":"Example Path datacenter <code>examples/datacenter/</code> homelab <code>examples/homelab/</code> devbox <code>examples/devbox/</code> graph-patterns <code>examples/graph-patterns/</code> drift-detection <code>examples/drift-detection/</code> federation <code>examples/federation/</code> type-composition <code>examples/type-composition/</code> 3-layer <code>examples/3-layer/</code> docker-bootstrap <code>examples/docker-bootstrap/</code> wiki-projection <code>examples/wiki-projection/</code> toon-export <code>examples/toon-export/</code> patterns-v2 <code>examples/patterns-v2/</code> reconciliation <code>examples/reconciliation/</code> showcase <code>examples/showcase/</code> sbom <code>examples/sbom/</code> ci <code>examples/ci/</code> universal-platform <code>examples/universal-platform/</code>"},{"location":"example/#running-an-example","title":"Running an example","text":"<pre><code># Validate\ncue vet ./examples/datacenter/\n\n# Summary\ncue eval ./examples/datacenter/ -e output.summary\n\n# Impact analysis\ncue eval ./examples/datacenter/ -e output.impact.\"router-core\"\n\n# JSON-LD export\ncue export ./examples/datacenter/ -e jsonld --out json\n</code></pre> <p>Each example is a self-contained CUE module under <code>examples/</code>. They import from <code>vocab/</code> and <code>patterns/</code> and can be evaluated independently.</p>"},{"location":"insights/","title":"Insights","text":"<p>14 validated discoveries from building the quicue ecosystem.</p> ID Statement Confidence Method INSIGHT-001 CUE transitive closure performance is topology-sensitive, not node-count-limited high experiment INSIGHT-002 CUE exports ALL public (capitalized) fields, causing unexpected JSON bloat high observation INSIGHT-003 CUE packages are directory-scoped \u2014 multi-graph knowledge bases leverage this for independent validation high experiment INSIGHT-004 Production data leaks through generated artifacts, not just source code high observation INSIGHT-005 cue vet does not fully evaluate hidden fields \u2014 test assertions on hidden values give false confidence high experiment INSIGHT-006 Everything is a projection of the same typed dependency graph \u2014 72+ projections exist high cross_reference INSIGHT-007 CUE unification obviates SPARQL \u2014 precomputed comprehensions ARE the query layer high experiment INSIGHT-008 When CUE comprehensions pre-compute all possible answers, the API is just a file server high experiment INSIGHT-009 Airgapped deployment has 8 reproducible traps high experiment INSIGHT-010 Three latent bugs in patterns/ went undetected because CUE's lax evaluation hides struct iteration errors high observation INSIGHT-011 W3C vocabulary alignment is mostly projection work \u2014 CUE's typed data already has the structure high cross_reference INSIGHT-012 ASCII-safe identifier constraints catch unicode injection at compile time high cross_reference INSIGHT-013 Export-facing CUE definitions systematically lack W3C @context and @id high cross_reference INSIGHT-014 Cloudflare API tokens are stored in ~/.ssh/ \u2014 the working token is cf-tk.token, not ~/.cf_env high observation"},{"location":"insights/#insight-001-cue-transitive-closure-performance-is-topology-sensitive-not-node-count-limited","title":"INSIGHT-001: CUE transitive closure performance is topology-sensitive, not node-count-limited","text":"<p>Method: experiment | Confidence: high | Discovered: 2025-12-01</p>"},{"location":"insights/#evidence","title":"Evidence","text":"<ul> <li>NHCF scenario with 25 nodes timed out \u2014 but due to wide fan-in, not node count</li> <li>Reducing to 18 nodes brought eval under 4 seconds by reducing fan-in</li> </ul>"},{"location":"insights/#implication","title":"Implication","text":"<p>Minimize edge density and fan-in for large graphs; Python precompute is a fallback for high-fan-in topologies</p> <p>Related: ADR-001</p>"},{"location":"insights/#insight-002-cue-exports-all-public-capitalized-fields-causing-unexpected-json-bloat","title":"INSIGHT-002: CUE exports ALL public (capitalized) fields, causing unexpected JSON bloat","text":"<p>Method: observation | Confidence: high | Discovered: 2025-11-15</p>"},{"location":"insights/#evidence_1","title":"Evidence","text":""},{"location":"insights/#vizexport-with-public-graph-field-exported-the-entire-input-graph-75kb-vs-17kb-expected","title":"VizExport with public Graph field exported the entire input graph (75KB vs 17KB expected)","text":""},{"location":"insights/#implication_1","title":"Implication","text":"<p>Export-facing definitions must use hidden fields (_prefix) for intermediate data</p> <p>Related: ADR-002</p>"},{"location":"insights/#insight-003-cue-packages-are-directory-scoped-multi-graph-knowledge-bases-leverage-this-for-independent-validation","title":"INSIGHT-003: CUE packages are directory-scoped \u2014 multi-graph knowledge bases leverage this for independent validation","text":"<p>Method: experiment | Confidence: high | Discovered: 2026-02-15</p>"},{"location":"insights/#evidence_2","title":"Evidence","text":"<ul> <li>.kb/ subdirectories create separate package instances \u2014 each graph validates independently</li> </ul>"},{"location":"insights/#implication_2","title":"Implication","text":"<p>Knowledge bases use typed subdirectories: each graph is an independent CUE package with its own cue.mod/</p> <p>Related: ADR-001</p>"},{"location":"insights/#insight-004-production-data-leaks-through-generated-artifacts-not-just-source-code","title":"INSIGHT-004: Production data leaks through generated artifacts, not just source code","text":"<p>Method: observation | Confidence: high | Discovered: 2026-02-18</p>"},{"location":"insights/#evidence_3","title":"Evidence","text":"<ul> <li>cat.quicue.ca had 98 real 172.20.x.x IPs in generated JSON</li> <li>Deploying safe data missed pre-existing files with different naming conventions</li> </ul>"},{"location":"insights/#implication_3","title":"Implication","text":"<p>When replacing data on public surfaces, grep -rl for real IPs across the ENTIRE web root</p> <p>Related: ADR-006</p>"},{"location":"insights/#insight-005-cue-vet-does-not-fully-evaluate-hidden-fields-test-assertions-on-hidden-values-give-false-confidence","title":"INSIGHT-005: cue vet does not fully evaluate hidden fields \u2014 test assertions on hidden values give false confidence","text":"<p>Method: experiment | Confidence: high | Discovered: 2026-02-18</p>"},{"location":"insights/#evidence_4","title":"Evidence","text":"<ul> <li>charter_test.cue asserts on a hidden field \u2014 cue vet passed even with conflicting values</li> </ul>"},{"location":"insights/#implication_4","title":"Implication","text":"<p>For critical invariants, use public fields or run cue eval -e to force evaluation</p> <p>Related: ADR-005, ADR-007</p>"},{"location":"insights/#insight-006-everything-is-a-projection-of-the-same-typed-dependency-graph-72-projections-exist","title":"INSIGHT-006: Everything is a projection of the same typed dependency graph \u2014 72+ projections exist","text":"<p>Method: cross_reference | Confidence: high | Discovered: 2026-02-18</p>"},{"location":"insights/#evidence_5","title":"Evidence","text":"<ul> <li>Terraform, Ansible, Rundeck, Jupyter, MkDocs, bash, HTTP, OpenAPI, Justfile, JSON-LD, Graphviz, Mermaid, TOON, N-Triples, DCAT \u2014 all from the same graph</li> </ul>"},{"location":"insights/#implication_5","title":"Implication","text":"<p>The graph is the single source of truth. Every artifact is a derived projection.</p> <p>Related: INSIGHT-002</p>"},{"location":"insights/#insight-007-cue-unification-obviates-sparql-precomputed-comprehensions-are-the-query-layer","title":"INSIGHT-007: CUE unification obviates SPARQL \u2014 precomputed comprehensions ARE the query layer","text":"<p>Method: experiment | Confidence: high | Discovered: 2026-02-18</p>"},{"location":"insights/#evidence_6","title":"Evidence","text":"<ul> <li>8 query patterns implemented as CUE definitions, no triplestore needed</li> </ul>"},{"location":"insights/#implication_6","title":"Implication","text":"<p>SPARQL is unnecessary for the primary use case. CUE comprehensions precompute all graph queries at eval time.</p> <p>Related: INSIGHT-006</p>"},{"location":"insights/#insight-008-when-cue-comprehensions-pre-compute-all-possible-answers-the-api-is-just-a-file-server","title":"INSIGHT-008: When CUE comprehensions pre-compute all possible answers, the API is just a file server","text":"<p>Method: experiment | Confidence: high | Discovered: 2026-02-18</p>"},{"location":"insights/#evidence_7","title":"Evidence","text":"<ul> <li>727 static JSON files replace FastAPI with zero server runtime</li> </ul>"},{"location":"insights/#implication_7","title":"Implication","text":"<p>If your domain model is a closed world and CUE comprehensions compute all queries at eval time, a CDN is the optimal runtime.</p> <p>Related: INSIGHT-007, ADR-012</p>"},{"location":"insights/#insight-009-airgapped-deployment-has-8-reproducible-traps","title":"INSIGHT-009: Airgapped deployment has 8 reproducible traps","text":"<p>Method: experiment | Confidence: high | Discovered: 2026-02-19</p>"},{"location":"insights/#evidence_8","title":"Evidence","text":"<ul> <li>E2E deployment on fresh Ubuntu 24.04 VM hit all 8 traps: ensurepip, typing_extensions, raptor2, cue.mod symlinks, Docker bind-mount, Caddy TLS, CUE OOM, grep pipefail</li> </ul>"},{"location":"insights/#implication_8","title":"Implication","text":"<p>Every package manager assumes internet access. Airgapped deployment has its own failure modes.</p> <p>Related: ADR-013</p>"},{"location":"insights/#insight-010-three-latent-bugs-in-patterns-went-undetected-because-cues-lax-evaluation-hides-struct-iteration-errors","title":"INSIGHT-010: Three latent bugs in patterns/ went undetected because CUE's lax evaluation hides struct iteration errors","text":"<p>Method: observation | Confidence: high | Discovered: 2026-02-19</p>"},{"location":"insights/#evidence_9","title":"Evidence","text":""},{"location":"insights/#bootstrapplan-used-lendepends_on-as-depth-proxy-wrong-for-peer-resources","title":"BootstrapPlan used len(depends_on) as depth proxy \u2014 wrong for peer resources","text":""},{"location":"insights/#validategraph-was-defined-in-both-graphcue-and-type-contractscue-cue-silently-unified-them","title":"ValidateGraph was defined in BOTH graph.cue and type-contracts.cue \u2014 CUE silently unified them","text":""},{"location":"insights/#dependencyvalidation-iterated-depends_on-as-an-array-but-the-codebase-uses-struct-as-set","title":"DependencyValidation iterated depends_on as an array but the codebase uses struct-as-set","text":""},{"location":"insights/#implication_9","title":"Implication","text":"<p>CUE's lazy evaluation means bugs hide in definitions that are syntactically valid but semantically wrong. Critical patterns need exercising examples.</p> <p>Related: INSIGHT-003</p>"},{"location":"insights/#insight-011-w3c-vocabulary-alignment-is-mostly-projection-work-cues-typed-data-already-has-the-structure","title":"INSIGHT-011: W3C vocabulary alignment is mostly projection work \u2014 CUE's typed data already has the structure","text":"<p>Method: cross_reference | Confidence: high | Discovered: 2026-02-19</p>"},{"location":"insights/#evidence_10","title":"Evidence","text":"<ul> <li>depends_on mapped from quicue:dependsOn to dcterms:requires \u2014 zero code change, just one IRI swap</li> <li> </li> </ul>"},{"location":"insights/#compliancecheck-results-already-have-the-structure-of-shvalidationreport-20-lines-to-project","title":"ComplianceCheck results already have the structure of sh:ValidationReport \u2014 20 lines to project","text":""},{"location":"insights/#implication_10","title":"Implication","text":"<p>When your data model is already typed and validated by CUE, W3C compliance is a thin projection layer.</p> <p>Related: INSIGHT-006, INSIGHT-007</p>"},{"location":"insights/#insight-012-ascii-safe-identifier-constraints-catch-unicode-injection-at-compile-time","title":"INSIGHT-012: ASCII-safe identifier constraints catch unicode injection at compile time","text":"<p>Method: cross_reference | Confidence: high | Discovered: 2026-02-19</p>"},{"location":"insights/#evidence_11","title":"Evidence","text":"<ul> <li>Cyrillic 'a' vs Latin 'a' creates distinct CUE keys that look identical</li> <li>Zero-width space in 'dnsserver' never matches 'dnsserver' in depends_on</li> </ul>"},{"location":"insights/#implication_11","title":"Implication","text":"<p>CUE's type system can enforce input validation at compile time. Unicode safety is a schema constraint.</p> <p>Related: ADR-014, INSIGHT-005</p>"},{"location":"insights/#insight-013-export-facing-cue-definitions-systematically-lack-w3c-context-and-id","title":"INSIGHT-013: Export-facing CUE definitions systematically lack W3C @context and @id","text":"<p>Method: cross_reference | Confidence: high | Discovered: 2026-02-20</p>"},{"location":"insights/#evidence_12","title":"Evidence","text":"<ul> <li>7 files producing structured output without proper JSON-LD framing</li> <li>Files WITH proper alignment were added intentionally, not systematically</li> </ul>"},{"location":"insights/#implication_12","title":"Implication","text":"<p>W3C compliance must be architectural, not ad-hoc. Every export-facing definition should include @context, @type, and dct:conformsTo.</p> <p>Related: INSIGHT-011, INSIGHT-006</p>"},{"location":"insights/#insight-014-cloudflare-api-tokens-are-stored-in-ssh-the-working-token-is-cf-tktoken-not-cf_env","title":"INSIGHT-014: Cloudflare API tokens are stored in ~/.ssh/ \u2014 the working token is cf-tk.token, not ~/.cf_env","text":"<p>Method: observation | Confidence: high | Discovered: 2026-02-20</p>"},{"location":"insights/#evidence_13","title":"Evidence","text":"<ul> <li>~/.cf_env exports CF_API_KEY \u2014 wrangler rejects it</li> <li>~/.ssh/cf-tk.token contains working CLOUDFLARE_API_TOKEN</li> </ul>"},{"location":"insights/#implication_13","title":"Implication","text":"<p>Token management needs a single source of truth. CF_API_KEY vs CLOUDFLARE_API_TOKEN naming mismatch caused repeated deploy failures.</p> <p>Related: INSIGHT-004</p>"},{"location":"modules/","title":"Modules","text":"<p>12 modules organized by architectural layer.</p>"},{"location":"modules/#by-layer","title":"By Layer","text":""},{"location":"modules/#definition","title":"definition","text":"<ul> <li>vocab \u2014 Core schemas: #Resource, #Action, #TypeRegistry, #ActionDef</li> <li>patterns \u2014 Algorithms: graph, bind, deploy, health, SPOF, viz, TOON, OpenAPI, validation</li> </ul>"},{"location":"modules/#template","title":"template","text":"<ul> <li>templates \u2014 29 platform-specific providers, each a self-contained CUE module</li> </ul>"},{"location":"modules/#orchestration","title":"orchestration","text":"<ul> <li>orche \u2014 Orchestration schemas: execution steps, federation, drift detection, Docker site bootstrap</li> <li>boot \u2014 Bootstrap schemas: #BootstrapResource, #BootstrapPlan, credential collectors</li> </ul>"},{"location":"modules/#constraint","title":"constraint","text":"<ul> <li>charter \u2014 Constraint-first project planning: declare scope, evaluate gaps, track gates. SHACL gap report projection.</li> </ul>"},{"location":"modules/#projection","title":"projection","text":"<ul> <li>wiki \u2014 #WikiProjection \u2014 MkDocs site generation from resource graphs</li> </ul>"},{"location":"modules/#reporting","title":"reporting","text":"<ul> <li>cab \u2014 Change Advisory Board reports: impact, blast radius, runbooks</li> </ul>"},{"location":"modules/#interaction","title":"interaction","text":"<ul> <li>ou \u2014 Role-scoped views: #InteractionCtx narrows #ExecutionPlan by role, type, name, layer. Hydra W3C JSON-LD export.</li> </ul>"},{"location":"modules/#ci","title":"ci","text":"<ul> <li>ci \u2014 Reusable GitLab CI templates for CUE validation, export, topology, impact</li> </ul>"},{"location":"modules/#operations","title":"operations","text":"<ul> <li>server \u2014 FastAPI execution gateway for running infrastructure commands</li> </ul>"},{"location":"modules/#value","title":"value","text":"<ul> <li>examples \u2014 17 working examples from minimal 3-layer to full 30-resource datacenter</li> </ul>"},{"location":"modules/#all-modules","title":"All Modules","text":"Module Layer Status Description vocab <code>definition</code> active Core schemas: #Resource, #Action, #TypeRegistry, #ActionDef patterns <code>definition</code> active Algorithms: graph, bind, deploy, health, SPOF, viz, TOON, OpenAPI, validation templates <code>template</code> active 29 platform-specific providers, each a self-contained CUE module orche <code>orchestration</code> active Orchestration schemas: execution steps, federation, drift detection, Docker site bootstrap boot <code>orchestration</code> active Bootstrap schemas: #BootstrapResource, #BootstrapPlan, credential collectors wiki <code>projection</code> active #WikiProjection \u2014 MkDocs site generation from resource graphs cab <code>reporting</code> active Change Advisory Board reports: impact, blast radius, runbooks ou <code>interaction</code> active Role-scoped views: #InteractionCtx narrows #ExecutionPlan by role, type, name, layer. Hydra W3C JSON-LD export. ci <code>ci</code> active Reusable GitLab CI templates for CUE validation, export, topology, impact server <code>operations</code> active FastAPI execution gateway for running infrastructure commands charter <code>constraint</code> active Constraint-first project planning: declare scope, evaluate gaps, track gates. SHACL gap report projection. examples <code>value</code> active 17 working examples from minimal 3-layer to full 30-resource datacenter"},{"location":"modules/boot/","title":"boot","text":"<p>Bootstrap schemas: #BootstrapResource, #BootstrapPlan, credential collectors</p> Field Value Path <code>boot/</code> Layer <code>orchestration</code> Status active"},{"location":"modules/boot/#purpose","title":"Purpose","text":"<p>Handles the bootstrap chicken-and-egg problem: you need DNS to reach the vault, but you need the vault to configure DNS. <code>boot/</code> models this as a sequenced plan with credential collection phases.</p>"},{"location":"modules/boot/#key-concepts","title":"Key Concepts","text":"<ul> <li><code>#BootstrapResource</code> \u2014 a resource with additional bootstrap metadata (credential requirements, first-run commands)</li> <li><code>#BootstrapPlan</code> \u2014 ordered bootstrap phases with dependency gates</li> <li>Credential collectors \u2014 typed declarations of what secrets are needed before a resource can start</li> </ul> <p>Bootstrap runs once to bring infrastructure from zero to a state where normal orchestration (<code>orche/</code>) can take over.</p>"},{"location":"modules/cab/","title":"cab","text":"<p>Change Advisory Board reports: impact, blast radius, runbooks</p> Field Value Path <code>cab/</code> Layer <code>reporting</code> Status active"},{"location":"modules/cab/#purpose","title":"Purpose","text":"<p>Generates Change Advisory Board reports from the graph's impact analysis. When you change a resource, <code>cab/</code> computes who needs to know and what could break.</p>"},{"location":"modules/cab/#what-it-produces","title":"What It Produces","text":"Output Description Impact summary Which resources are affected, direct and transitive Blast radius How far the change propagates through dependency layers Rollback plan Reverse-order steps to undo the change Runbook Step-by-step execution plan for the change <p>Input is an <code>#ExecutionPlan</code> \u2014 the same unified structure that powers deployment, visualization, and documentation.</p>"},{"location":"modules/charter/","title":"charter","text":"<p>Constraint-first project planning: declare scope, evaluate gaps, track gates. SHACL gap report projection.</p> Field Value Path <code>charter/</code> Layer <code>constraint</code> Status active"},{"location":"modules/charter/#dependencies","title":"Dependencies","text":"<ul> <li>patterns</li> </ul>"},{"location":"modules/charter/#schemas","title":"Schemas","text":"<ul> <li><code>#Charter</code></li> <li><code>#Gate</code></li> <li><code>#GapAnalysis</code></li> <li><code>#Milestone</code></li> <li><code>#InfraCharter</code></li> </ul>"},{"location":"modules/ci/","title":"ci","text":"<p>Reusable GitLab CI templates for CUE validation, export, topology, impact</p> Field Value Path <code>ci/gitlab/</code> Layer <code>ci</code> Status active"},{"location":"modules/ci/#purpose","title":"Purpose","text":"<p>Reusable GitLab CI job templates that any downstream project can include. Each template runs a specific CUE operation and reports results as pipeline artifacts.</p>"},{"location":"modules/ci/#templates","title":"Templates","text":"Template What It Does <code>validate</code> <code>cue vet</code> on all CUE packages <code>export</code> <code>cue export</code> to JSON for downstream consumption <code>topology</code> Graph analysis \u2014 depth, layers, critical path <code>impact</code> Blast radius and SPOF analysis <p>Usage: include the templates in your <code>.gitlab-ci.yml</code> and override the <code>CUE_PACKAGE</code> variable.</p>"},{"location":"modules/examples/","title":"examples","text":"<p>17 working examples from minimal 3-layer to full 30-resource datacenter</p> Field Value Path <code>examples/</code> Layer <code>value</code> Status active"},{"location":"modules/examples/#entries","title":"Entries","text":"<ul> <li><code>datacenter</code></li> <li><code>homelab</code></li> <li><code>devbox</code></li> <li><code>graph-patterns</code></li> <li><code>drift-detection</code></li> <li><code>federation</code></li> <li><code>type-composition</code></li> <li><code>3-layer</code></li> <li><code>docker-bootstrap</code></li> <li><code>wiki-projection</code></li> <li><code>toon-export</code></li> <li><code>patterns-v2</code></li> <li><code>reconciliation</code></li> <li><code>showcase</code></li> <li><code>sbom</code></li> <li><code>ci</code></li> <li><code>universal-platform</code></li> </ul>"},{"location":"modules/orche/","title":"orche","text":"<p>Orchestration schemas: execution steps, federation, drift detection, Docker site bootstrap</p> Field Value Path <code>orche/</code> Layer <code>orchestration</code> Status active"},{"location":"modules/orche/#dependencies","title":"Dependencies","text":"<ul> <li>patterns</li> </ul>"},{"location":"modules/orche/#packages","title":"Packages","text":"<ul> <li><code>orchestration</code></li> <li><code>bootstrap</code></li> <li><code>schema</code></li> </ul>"},{"location":"modules/ou/","title":"ou","text":"<p>Role-scoped views: #InteractionCtx narrows #ExecutionPlan by role, type, name, layer. Hydra W3C JSON-LD export.</p> Field Value Path <code>ou/</code> Layer <code>interaction</code> Status active"},{"location":"modules/ou/#dependencies","title":"Dependencies","text":"<ul> <li>patterns</li> </ul>"},{"location":"modules/ou/#purpose","title":"Purpose","text":"<p>Role-scoped views that filter the full <code>#ExecutionPlan</code> down to what a specific user should see and do. Three built-in roles:</p> Role Access Use Case <code>ops</code> Full \u2014 all resources, all actions Infrastructure operators <code>dev</code> Read-only monitoring \u2014 status, logs, metrics Developers <code>readonly</code> Status queries only \u2014 no mutations Dashboards, auditors"},{"location":"modules/ou/#w3c-hydra-export","title":"W3C Hydra Export","text":"<p><code>ou/</code> also exports a W3C Hydra JSON-LD API description. Each resource type becomes a <code>hydra:Class</code> with <code>supportedOperation</code> entries \u2014 enabling semantic API navigation for frontends that understand linked data.</p>"},{"location":"modules/patterns/","title":"patterns","text":"<p>Algorithms: graph, bind, deploy, health, SPOF, viz, TOON, OpenAPI, validation</p> Field Value Path <code>patterns/</code> Layer <code>definition</code> Status active"},{"location":"modules/patterns/#schemas","title":"Schemas","text":"<ul> <li><code>#InfraGraph</code></li> <li><code>#BindCluster</code></li> <li><code>#ExecutionPlan</code></li> <li><code>#ImpactQuery</code></li> <li><code>#BlastRadius</code></li> <li><code>#SinglePointsOfFailure</code></li> <li><code>#CriticalityRank</code></li> <li><code>#HealthStatus</code></li> <li><code>#RollbackPlan</code></li> <li><code>#DeploymentPlan</code></li> <li><code>#TOONExport</code></li> <li><code>#ExportGraph</code></li> <li><code>#ValidateGraph</code></li> <li><code>#ValidateTypes</code></li> <li><code>#GroupByType</code></li> <li><code>#GraphMetrics</code></li> <li><code>#ImmediateDependents</code></li> <li><code>#DependencyChain</code></li> <li><code>#CycleDetector</code></li> <li><code>#ConnectedComponents</code></li> <li><code>#Subgraph</code></li> <li><code>#GraphDiff</code></li> <li><code>#CriticalPath</code></li> <li><code>#ComplianceCheck</code></li> <li><code>#LifecyclePhasesSKOS</code></li> </ul>"},{"location":"modules/server/","title":"server","text":"<p>FastAPI execution gateway for running infrastructure commands</p> Field Value Path <code>server/</code> Layer <code>operations</code> Status active <p>Note</p> <p>Standalone. Consumes CUE-generated specs but does not depend on CUE at build time.</p>"},{"location":"modules/server/#purpose","title":"Purpose","text":"<p>HTTP API gateway that executes resolved commands from CUE-generated action plans. Reads the OpenAPI spec produced by <code>#OpenAPISpec</code> and exposes each action as a REST endpoint.</p>"},{"location":"modules/server/#architecture","title":"Architecture","text":"<pre><code>CUE export \u2192 OpenAPI spec \u2192 FastAPI routes \u2192 command execution\n</code></pre> <p>The server never interprets CUE directly. It reads the pre-computed JSON output. This means the server is stateless and the CUE evaluation is a build step, not a runtime dependency.</p> <p>Live demo: api.quicue.ca/docs (public, mock mode \u2014 no real infrastructure commands execute)</p>"},{"location":"modules/templates/","title":"templates","text":"<p>29 platform-specific providers, each a self-contained CUE module</p> Field Value Path <code>template/*/</code> Layer <code>template</code> Status active"},{"location":"modules/templates/#categories","title":"Categories","text":"Category Entries compute <code>proxmox</code>, <code>govc</code>, <code>powercli</code>, <code>kubevirt</code> container <code>docker</code>, <code>incus</code>, <code>k3d</code>, <code>kubectl</code>, <code>argocd</code> cicd <code>dagger</code>, <code>gitlab</code> networking <code>vyos</code>, <code>caddy</code>, <code>nginx</code> dns <code>cloudflare</code>, <code>powerdns</code>, <code>technitium</code> identity <code>vault</code>, <code>keycloak</code> database <code>postgresql</code> dcim <code>netbox</code> provisioning <code>foreman</code> automation <code>ansible</code>, <code>awx</code> monitoring <code>zabbix</code> iac <code>terraform</code>, <code>opentofu</code> backup <code>restic</code>, <code>pbs</code>"},{"location":"modules/vocab/","title":"vocab","text":"<p>Core schemas: #Resource, #Action, #TypeRegistry, #ActionDef</p> Field Value Path <code>vocab/</code> Layer <code>definition</code> Status active"},{"location":"modules/vocab/#key-definitions","title":"Key Definitions","text":"Schema Purpose <code>#Resource</code> Foundation type \u2014 every infrastructure component is a resource with <code>@type</code>, <code>depends_on</code>, and provider-specific fields <code>#Action</code> A resolved action with a concrete <code>command</code> string (output of binding) <code>#ActionDef</code> An action definition with typed parameters and a command template (provider declares these) <code>#TypeRegistry</code> The 57 semantic types that classify what resources ARE <code>#SafeID</code> ASCII-safe identifier constraint \u2014 prevents unicode injection at compile time"},{"location":"modules/vocab/#design-decisions","title":"Design Decisions","text":"<ul> <li>Struct-as-set for <code>@type</code> and <code>depends_on</code> \u2014 <code>{LXCContainer: true}</code> gives O(1) membership</li> <li>Open schema (<code>...</code>) \u2014 resources carry domain-specific fields without modifying vocab</li> <li>Generic field names \u2014 <code>host</code> not <code>node</code>, <code>container_id</code> not <code>lxcid</code></li> </ul> <p>See ADR-002 (struct-as-set) and ADR-014 (ASCII-safe identifiers).</p>"},{"location":"modules/wiki/","title":"wiki","text":""},{"location":"modules/wiki/#wikiprojection-mkdocs-site-generation-from-resource-graphs","title":"WikiProjection \u2014 MkDocs site generation from resource graphs","text":"Field Value Path <code>wiki/</code> Layer <code>projection</code> Status active"},{"location":"modules/wiki/#purpose","title":"Purpose","text":"<p>Generates MkDocs-compatible markdown documentation from any <code>#ExecutionPlan</code>. Given a resource graph with resolved bindings, <code>wiki/</code> produces a complete documentation site: index page, per-layer views, per-resource detail pages.</p> <p>This is the same module that powers <code>docs.quicue.ca</code> \u2014 the <code>#DocsProjection</code> in this directory is a sibling projection that consumes registry data instead of resource graphs.</p>"},{"location":"modules/wiki/#key-schema","title":"Key Schema","text":"<p><code>#WikiProjection</code> takes: - <code>Resources</code> \u2014 the resource graph - <code>Bound</code> \u2014 resolved bindings from <code>#BindCluster</code> - <code>Graph</code> \u2014 topology from <code>#InfraGraph</code> - <code>Plan</code> \u2014 deployment layers from <code>#DeploymentPlan</code></p> <p>And produces <code>files: {[path]: content}</code> + <code>stats</code> + <code>mkdocs</code> nav fragment.</p>"},{"location":"patterns-kb/","title":"Knowledge Base Patterns","text":"<p>16 validated problem/solution pairs organized by category.</p>"},{"location":"patterns-kb/#by-category","title":"By Category","text":""},{"location":"patterns-kb/#data","title":"data","text":"<ul> <li>Struct-as-Set</li> </ul>"},{"location":"patterns-kb/#architecture","title":"architecture","text":"<ul> <li>Three-Layer Architecture</li> <li>Compile-Time Binding</li> <li>Universe Cheat Sheet</li> <li>Everything-is-a-Projection</li> <li>Types-Compose-Scripts-Don't</li> <li>Static-First</li> </ul>"},{"location":"patterns-kb/#cue","title":"cue","text":"<ul> <li>Hidden Wrapper for Exports</li> <li>Hidden Intermediary for Nested Structs</li> </ul>"},{"location":"patterns-kb/#verification","title":"verification","text":"<ul> <li>Contract-via-Unification</li> </ul>"},{"location":"patterns-kb/#planning","title":"planning","text":"<ul> <li>Gap-as-Backlog</li> </ul>"},{"location":"patterns-kb/#operations","title":"operations","text":"<ul> <li>Safe Deploy Pipeline</li> <li>Idempotent-by-Construction</li> <li>Airgapped Bundle</li> </ul>"},{"location":"patterns-kb/#adoption","title":"adoption","text":"<ul> <li>Graph Projection from Existing Config</li> </ul>"},{"location":"patterns-kb/#security","title":"security","text":"<ul> <li>ASCII-Safe Identifiers</li> </ul>"},{"location":"patterns-kb/#all-patterns","title":"All Patterns","text":"Pattern Category Used In Struct-as-Set data apercue, datacenter, quicue.ca Three-Layer Architecture architecture quicue.ca Compile-Time Binding architecture quicue.ca Hidden Wrapper for Exports cue quicue.ca Contract-via-Unification verification quicue.ca, cmhc-retrofit, maison-613, grdn Gap-as-Backlog planning quicue.ca Universe Cheat Sheet architecture quicue.ca Safe Deploy Pipeline operations quicue.ca Hidden Intermediary for Nested Structs cue quicue.ca, cmhc-retrofit, charter Graph Projection from Existing Config adoption grdn Everything-is-a-Projection architecture quicue.ca, apercue Idempotent-by-Construction operations quicue.ca Types-Compose-Scripts-Don't architecture quicue.ca Static-First architecture quicue.ca Airgapped Bundle operations quicue.ca ASCII-Safe Identifiers security apercue, quicue.ca, cmhc-retrofit, grdn, maison-613"},{"location":"patterns-kb/airgapped-bundle/","title":"Airgapped Bundle","text":"<p>Category: operations</p>"},{"location":"patterns-kb/airgapped-bundle/#problem","title":"Problem","text":"<p>Deploying to air-gapped or restricted networks fails because package managers (apt, pip, docker pull) require internet access. Partial offline solutions miss transitive dependencies or version conflicts.</p>"},{"location":"patterns-kb/airgapped-bundle/#solution","title":"Solution","text":"<p>Define a #Bundle CUE schema declaring all artifacts needed for offline deployment: git repos, Docker images (app + base), Python wheels (including pip bootstrap), static binaries, and system packages with recursive dependencies. A #Gotcha registry captures known deployment traps with tested workarounds. bundle.sh reads the manifest and collects everything. install-airgapped.sh deploys on the target.</p>"},{"location":"patterns-kb/airgapped-bundle/#context","title":"Context","text":"<p>Any deployment to networks with restricted internet access: institutional data centers, classified environments, factory floors, or POC demonstrations that must work reliably without external dependencies.</p>"},{"location":"patterns-kb/airgapped-bundle/#example","title":"Example","text":"<p><code>operator/airgap-bundle.cue defines #Bundle + #Gotcha. E2E proven: 284MB bundle \u2192 fresh Ubuntu 24.04 VM \u2192 37/37 smoke tests on completely airgapped machine.</code></p>"},{"location":"patterns-kb/airgapped-bundle/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> </ul>"},{"location":"patterns-kb/airgapped-bundle/#see-also","title":"See Also","text":"<ul> <li>Idempotent-by-Construction</li> <li>Types-Compose-Scripts-Don't</li> <li>Safe Deploy Pipeline</li> </ul>"},{"location":"patterns-kb/ascii-safe-identifiers/","title":"ASCII-Safe Identifiers","text":"<p>Category: security</p>"},{"location":"patterns-kb/ascii-safe-identifiers/#problem","title":"Problem","text":"<p>CUE unification treats strings as opaque byte sequences. Unicode homoglyphs (Cyrillic '\u0430' vs Latin 'a'), zero-width characters (U+200B), and RTL overrides (U+202E) create visually identical but structurally distinct keys.</p>"},{"location":"patterns-kb/ascii-safe-identifiers/#solution","title":"Solution","text":"<p>Constrain all graph identifiers to ASCII via regex at the definition layer. #SafeID for resource names and dependency references. #SafeLabel for type names, tags, and registry keys. cue vet enforces at compile time with zero runtime cost.</p>"},{"location":"patterns-kb/ascii-safe-identifiers/#context","title":"Context","text":"<p>Any CUE schema where string values participate in struct key lookup, unification, or cross-reference. Especially critical for @type (provider matching), depends_on (graph edges), and name (identity).</p>"},{"location":"patterns-kb/ascii-safe-identifiers/#example","title":"Example","text":"<p><code>#SafeID: =~\"^[a-zA-Z][a-zA-Z0-9_.-]*$\"; #SafeLabel: =~\"^[a-zA-Z][a-zA-Z0-9_-]*$\"</code></p>"},{"location":"patterns-kb/ascii-safe-identifiers/#used-in","title":"Used In","text":"<ul> <li>apercue</li> <li>quicue.ca</li> <li>cmhc-retrofit</li> <li>grdn</li> <li>maison-613</li> </ul>"},{"location":"patterns-kb/ascii-safe-identifiers/#see-also","title":"See Also","text":"<ul> <li>Struct-as-Set</li> <li>Contract-via-Unification</li> </ul>"},{"location":"patterns-kb/compile-time-binding/","title":"Compile-Time Binding","text":"<p>Category: architecture</p>"},{"location":"patterns-kb/compile-time-binding/#problem","title":"Problem","text":"<p>Command templates with runtime placeholders can fail at execution time if a field is missing.</p>"},{"location":"patterns-kb/compile-time-binding/#solution","title":"Solution","text":"<p>Resolve all template parameters at CUE evaluation time using #ResolveTemplate. No placeholders survive.</p>"},{"location":"patterns-kb/compile-time-binding/#context","title":"Context","text":"<p>Provider action templates where parameters come from resource fields.</p>"},{"location":"patterns-kb/compile-time-binding/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> </ul>"},{"location":"patterns-kb/compile-time-binding/#see-also","title":"See Also","text":"<ul> <li>Struct-as-Set</li> </ul>"},{"location":"patterns-kb/contract-via-unification/","title":"Contract-via-Unification","text":"<p>Category: verification</p>"},{"location":"patterns-kb/contract-via-unification/#problem","title":"Problem","text":"<p>Projects need to verify graph invariants but traditional assertion frameworks add a separate test layer.</p>"},{"location":"patterns-kb/contract-via-unification/#solution","title":"Solution","text":"<p>Write CUE constraints as plain struct values that must unify with computed output. The language IS the test harness.</p>"},{"location":"patterns-kb/contract-via-unification/#context","title":"Context","text":"<p>Any project with a dependency graph where structural invariants must hold.</p>"},{"location":"patterns-kb/contract-via-unification/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> <li>cmhc-retrofit</li> <li>maison-613</li> <li>grdn</li> </ul>"},{"location":"patterns-kb/contract-via-unification/#see-also","title":"See Also","text":"<ul> <li>Struct-as-Set</li> <li>Hidden Wrapper for Exports</li> <li>Gap-as-Backlog</li> </ul>"},{"location":"patterns-kb/everything-is-a-projection/","title":"Everything-is-a-Projection","text":"<p>Category: architecture</p>"},{"location":"patterns-kb/everything-is-a-projection/#problem","title":"Problem","text":"<p>Adding new output formats requires writing new code in each target language, duplicating graph traversal.</p>"},{"location":"patterns-kb/everything-is-a-projection/#solution","title":"Solution","text":"<p>Maintain one canonical CUE graph. Every output format is a CUE comprehension over that graph.</p>"},{"location":"patterns-kb/everything-is-a-projection/#context","title":"Context","text":"<p>Any CUE project that produces multiple output formats from the same source data.</p>"},{"location":"patterns-kb/everything-is-a-projection/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> <li>apercue</li> </ul>"},{"location":"patterns-kb/everything-is-a-projection/#see-also","title":"See Also","text":"<ul> <li>Compile-Time Binding</li> <li>Universe Cheat Sheet</li> <li>Hidden Wrapper for Exports</li> </ul>"},{"location":"patterns-kb/gap-as-backlog/","title":"Gap-as-Backlog","text":"<p>Category: planning</p>"},{"location":"patterns-kb/gap-as-backlog/#problem","title":"Problem","text":"<p>Project planning tools track work items separately from the system. The backlog drifts.</p>"},{"location":"patterns-kb/gap-as-backlog/#solution","title":"Solution","text":"<p>Declare 'done' as CUE constraints on an incomplete graph. The gap IS the remaining work.</p>"},{"location":"patterns-kb/gap-as-backlog/#context","title":"Context","text":"<p>Any project built incrementally where completion criteria can be expressed as graph properties.</p>"},{"location":"patterns-kb/gap-as-backlog/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> </ul>"},{"location":"patterns-kb/gap-as-backlog/#see-also","title":"See Also","text":"<ul> <li>Contract-via-Unification</li> <li>Struct-as-Set</li> </ul>"},{"location":"patterns-kb/graph-projection-from-existing-config/","title":"Graph Projection from Existing Config","text":"<p>Category: adoption</p>"},{"location":"patterns-kb/graph-projection-from-existing-config/#problem","title":"Problem","text":"<p>Existing CUE codebases don't use @type or depends_on. Rewriting is invasive.</p>"},{"location":"patterns-kb/graph-projection-from-existing-config/#solution","title":"Solution","text":"<p>Write a single additive file (graph.cue) that reads from existing config fields and produces a flat resource map.</p>"},{"location":"patterns-kb/graph-projection-from-existing-config/#context","title":"Context","text":"<p>Any existing CUE project considering adoption of quicue.ca patterns.</p>"},{"location":"patterns-kb/graph-projection-from-existing-config/#used-in","title":"Used In","text":"<ul> <li>grdn</li> </ul>"},{"location":"patterns-kb/graph-projection-from-existing-config/#see-also","title":"See Also","text":"<ul> <li>Struct-as-Set</li> <li>Three-Layer Architecture</li> </ul>"},{"location":"patterns-kb/hidden-intermediary-for-nested-structs/","title":"Hidden Intermediary for Nested Structs","text":"<p>Category: cue</p>"},{"location":"patterns-kb/hidden-intermediary-for-nested-structs/#problem","title":"Problem","text":"<p>CUE field references inside nested structs resolve to the nearest enclosing scope, causing self-references.</p>"},{"location":"patterns-kb/hidden-intermediary-for-nested-structs/#solution","title":"Solution","text":"<p>Define hidden intermediaries at the outer scope: _total: total. Then reference them inside the nested struct.</p>"},{"location":"patterns-kb/hidden-intermediary-for-nested-structs/#context","title":"Context","text":"<p>Any CUE definition that copies outer field values into a nested summary or output struct.</p>"},{"location":"patterns-kb/hidden-intermediary-for-nested-structs/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> <li>cmhc-retrofit</li> <li>charter</li> </ul>"},{"location":"patterns-kb/hidden-intermediary-for-nested-structs/#see-also","title":"See Also","text":"<ul> <li>Hidden Wrapper for Exports</li> <li>Contract-via-Unification</li> </ul>"},{"location":"patterns-kb/hidden-wrapper-for-exports/","title":"Hidden Wrapper for Exports","text":"<p>Category: cue</p>"},{"location":"patterns-kb/hidden-wrapper-for-exports/#problem","title":"Problem","text":"<p>CUE exports all public fields. Definitions with large input as public fields leak that data.</p>"},{"location":"patterns-kb/hidden-wrapper-for-exports/#solution","title":"Solution","text":"<p>Use hidden fields (_prefix) for intermediate computation. Expose only the final projection.</p>"},{"location":"patterns-kb/hidden-wrapper-for-exports/#context","title":"Context","text":"<p>Any CUE definition that produces export-ready JSON from larger input data.</p>"},{"location":"patterns-kb/hidden-wrapper-for-exports/#example","title":"Example","text":"<p><code>_viz holds computation, viz: {data: _viz.data} exposes output only</code></p>"},{"location":"patterns-kb/hidden-wrapper-for-exports/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> </ul>"},{"location":"patterns-kb/idempotent-by-construction/","title":"Idempotent-by-Construction","text":"<p>Category: operations</p>"},{"location":"patterns-kb/idempotent-by-construction/#problem","title":"Problem","text":"<p>Deployment scripts accumulate state. Re-running a partially-failed deployment is risky.</p>"},{"location":"patterns-kb/idempotent-by-construction/#solution","title":"Solution","text":"<p>CUE evaluation is deterministic \u2014 same inputs always produce identical outputs. The deployment artifact is immutable.</p>"},{"location":"patterns-kb/idempotent-by-construction/#context","title":"Context","text":"<p>Any deployment pipeline where re-runnability matters.</p>"},{"location":"patterns-kb/idempotent-by-construction/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> </ul>"},{"location":"patterns-kb/idempotent-by-construction/#see-also","title":"See Also","text":"<ul> <li>Compile-Time Binding</li> <li>Contract-via-Unification</li> </ul>"},{"location":"patterns-kb/safe-deploy-pipeline/","title":"Safe Deploy Pipeline","text":"<p>Category: operations</p>"},{"location":"patterns-kb/safe-deploy-pipeline/#problem","title":"Problem","text":"<p>Public surfaces built from production data leak real IPs and internal topology.</p>"},{"location":"patterns-kb/safe-deploy-pipeline/#solution","title":"Solution","text":"<p>Source all public data from a single safe example (RFC 5737 TEST-NET IPs). Delete all existing files before deploying.</p>"},{"location":"patterns-kb/safe-deploy-pipeline/#context","title":"Context","text":"<p>Any project deploying generated artifacts to public web surfaces.</p>"},{"location":"patterns-kb/safe-deploy-pipeline/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> </ul>"},{"location":"patterns-kb/safe-deploy-pipeline/#see-also","title":"See Also","text":"<ul> <li>Compile-Time Binding</li> </ul>"},{"location":"patterns-kb/static-first/","title":"Static-First","text":"<p>Category: architecture</p>"},{"location":"patterns-kb/static-first/#problem","title":"Problem","text":"<p>Web servers introduce failure modes even when serving read-only data that changes only at build time.</p>"},{"location":"patterns-kb/static-first/#solution","title":"Solution","text":"<p>Pre-compute everything possible at cue export time. Read-only API surfaces are directories of JSON files served by CDN.</p>"},{"location":"patterns-kb/static-first/#context","title":"Context","text":"<p>Deployment dashboards, API documentation, graph visualization, risk reports.</p>"},{"location":"patterns-kb/static-first/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> </ul>"},{"location":"patterns-kb/static-first/#see-also","title":"See Also","text":"<ul> <li>Universe Cheat Sheet</li> <li>Everything-is-a-Projection</li> <li>Safe Deploy Pipeline</li> </ul>"},{"location":"patterns-kb/struct-as-set/","title":"Struct-as-Set","text":"<p>Category: data</p>"},{"location":"patterns-kb/struct-as-set/#problem","title":"Problem","text":"<p>Arrays allow duplicates, require O(n) membership checks, and collide on unification.</p>"},{"location":"patterns-kb/struct-as-set/#solution","title":"Solution","text":"<p>Use {[string]: true} for sets. O(1) membership, automatic dedup, clean unification via CUE lattice.</p>"},{"location":"patterns-kb/struct-as-set/#context","title":"Context","text":"<p>Any field representing membership, tags, categories, or dependency sets.</p>"},{"location":"patterns-kb/struct-as-set/#example","title":"Example","text":"<p><code>apercue/.kb/decisions/002-struct-as-set.cue</code></p>"},{"location":"patterns-kb/struct-as-set/#used-in","title":"Used In","text":"<ul> <li>apercue</li> <li>datacenter</li> <li>quicue.ca</li> </ul>"},{"location":"patterns-kb/struct-as-set/#see-also","title":"See Also","text":"<ul> <li>bidirectional deps</li> <li>referential integrity</li> </ul>"},{"location":"patterns-kb/three-layer-architecture/","title":"Three-Layer Architecture","text":"<p>Category: architecture</p>"},{"location":"patterns-kb/three-layer-architecture/#problem","title":"Problem","text":"<p>Infrastructure models mix universal concepts with platform-specific implementations and concrete instances.</p>"},{"location":"patterns-kb/three-layer-architecture/#solution","title":"Solution","text":"<p>Separate into definition, template, and value layers. Each layer constrains the next via CUE unification.</p>"},{"location":"patterns-kb/three-layer-architecture/#context","title":"Context","text":"<p>Infrastructure-as-code projects where the same resource model applies across multiple platforms.</p>"},{"location":"patterns-kb/three-layer-architecture/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> </ul>"},{"location":"patterns-kb/three-layer-architecture/#see-also","title":"See Also","text":"<ul> <li>Compile-Time Binding</li> </ul>"},{"location":"patterns-kb/types-compose-scripts-don%27t/","title":"Types-Compose-Scripts-Don't","text":"<p>Category: architecture</p>"},{"location":"patterns-kb/types-compose-scripts-don%27t/#problem","title":"Problem","text":"<p>Adding new deployment capabilities typically means writing new bash scripts that duplicate graph traversal.</p>"},{"location":"patterns-kb/types-compose-scripts-don%27t/#solution","title":"Solution","text":"<p>Express new capabilities as CUE types that compose with existing types via unification.</p>"},{"location":"patterns-kb/types-compose-scripts-don%27t/#context","title":"Context","text":"<p>Any extension to the deployment lifecycle where the new capability needs access to the resource graph.</p>"},{"location":"patterns-kb/types-compose-scripts-don%27t/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> </ul>"},{"location":"patterns-kb/types-compose-scripts-don%27t/#see-also","title":"See Also","text":"<ul> <li>Three-Layer Architecture</li> <li>Everything-is-a-Projection</li> </ul>"},{"location":"patterns-kb/universe-cheat-sheet/","title":"Universe Cheat Sheet","text":"<p>Category: architecture</p>"},{"location":"patterns-kb/universe-cheat-sheet/#problem","title":"Problem","text":"<p>Read-only APIs backed by CUE graphs still deploy a web server, adding latency and failure modes.</p>"},{"location":"patterns-kb/universe-cheat-sheet/#solution","title":"Solution","text":"<p>Run cue export once to produce all possible API responses as static JSON files. Deploy to CDN.</p>"},{"location":"patterns-kb/universe-cheat-sheet/#context","title":"Context","text":"<p>Any CUE-backed API where the query universe is finite and data changes only at build time.</p>"},{"location":"patterns-kb/universe-cheat-sheet/#used-in","title":"Used In","text":"<ul> <li>quicue.ca</li> </ul>"},{"location":"patterns-kb/universe-cheat-sheet/#see-also","title":"See Also","text":"<ul> <li>Compile-Time Binding</li> <li>Safe Deploy Pipeline</li> </ul>"},{"location":"types/","title":"Type Registry","text":"<p>57 semantic types for infrastructure resources. Types describe WHAT a resource IS, not what it can do. Actions are defined by providers, not by type declarations.</p>"},{"location":"types/#types","title":"Types","text":"Type Description <code>LXCContainer</code> Proxmox LXC container <code>DockerContainer</code> Docker container <code>ComposeStack</code> Docker Compose application stack <code>VirtualMachine</code> Virtual machine (Proxmox QEMU, VMware, etc.) <code>DockerHost</code> Docker daemon host <code>KubernetesService</code> Kubernetes workload <code>VMwareCluster</code> VMware vSphere / vCenter cluster <code>Router</code> Network router/firewall <code>KubernetesCluster</code> Kubernetes cluster (k3s, k8s, OpenShift) <code>DNSServer</code> DNS/name resolution server <code>ReverseProxy</code> HTTP/HTTPS reverse proxy <code>VirtualizationPlatform</code> Hypervisor node (Proxmox, VMware) <code>SourceControlManagement</code> Git server (Forgejo, GitLab, Gitea) <code>Bastion</code> SSH jump host / bastion server <code>Vault</code> Secrets management <code>MonitoringServer</code> Metrics/alerting server <code>LogAggregator</code> Log collection and aggregation <code>DevelopmentWorkstation</code> Developer machine <code>GPUCompute</code> GPU-enabled compute node <code>AuthServer</code> Authentication/identity provider <code>LoadBalancer</code> Load balancer / traffic distribution <code>MessageQueue</code> Message broker (RabbitMQ, Kafka, NATS) <code>CacheCluster</code> Distributed cache (Redis, Memcached) <code>Database</code> Database server (PostgreSQL, MySQL, MongoDB) <code>SearchIndex</code> Search engine (Elasticsearch, Meilisearch) <code>HomeAutomation</code> Home automation platform <code>ObjectStorage</code> S3-compatible object storage <code>ContainerRegistry</code> OCI/Docker registry <code>TracingBackend</code> Distributed tracing (Jaeger, Zipkin, Tempo) <code>StatusMonitor</code> Uptime/status monitoring <code>CIRunner</code> CI/CD job runner <code>MediaServer</code> Media streaming server <code>PhotoManagement</code> Photo library management <code>AudiobookLibrary</code> Audiobook server <code>EbookLibrary</code> Ebook server <code>RecipeManager</code> Recipe/meal planning <code>TunnelEndpoint</code> Network tunnel (Cloudflared, WireGuard, Tailscale) <code>Network</code> Network zone / address space <code>EdgeNode</code> Edge/remote site node <code>APIServer</code> API backend service <code>WebFrontend</code> Web frontend / UI server <code>Worker</code> Background job processor <code>ScheduledJob</code> Cron/scheduled task runner <code>Region</code> Geographic region / data center location <code>AvailabilityZone</code> Availability zone within a region <code>SoftwareApplication</code> Software application or service binary <code>SoftwareLibrary</code> Software library or package dependency <code>SoftwareFramework</code> Software framework (Spring, Django, Rails) <code>SoftwareContainer</code> Container image artifact (OCI, Docker) <code>SoftwarePlatform</code> Runtime platform (JVM, Node.js, .NET CLR) <code>SoftwareFirmware</code> Embedded firmware component <code>SoftwareFile</code> Single file artifact in SBOM <code>OperatingSystem</code> Operating system (Ubuntu, Alpine, Windows) <code>CIPipeline</code> CI/CD pipeline definition <code>CIStage</code> Stage within a CI/CD pipeline <code>CIJob</code> Individual job within a CI/CD stage <code>CriticalInfra</code> Critical infrastructure - extra monitoring/alerting"},{"location":"types/#usage","title":"Usage","text":"<pre><code>import \"quicue.ca/vocab@v0\"\n\nmyResource: vocab.#Resource &amp; {\n    \"@type\": {LXCContainer: true, DNSServer: true}\n}\n</code></pre>"},{"location":"types/#categories","title":"Categories","text":"<ul> <li>Implementation (how it runs): <code>LXCContainer</code>, <code>VirtualMachine</code>, <code>DockerContainer</code>, <code>ComposeStack</code>, <code>DockerHost</code></li> <li>Semantic (what it does): <code>DNSServer</code>, <code>ReverseProxy</code>, <code>Database</code>, <code>Vault</code>, <code>MonitoringServer</code></li> <li>Classification (operational tier): <code>CriticalInfra</code></li> </ul> <p>A resource can have multiple types. A Proxmox LXC running PowerDNS is <code>{LXCContainer: true, DNSServer: true}</code> \u2014 it gets both container management actions from the proxmox provider AND DNS-specific actions from the powerdns provider.</p>"}]}